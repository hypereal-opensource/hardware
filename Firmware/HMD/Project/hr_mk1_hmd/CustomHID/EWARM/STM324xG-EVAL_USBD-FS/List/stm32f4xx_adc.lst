###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.2.7424/W32 for ARM        10/Feb/2017  19:48:01
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\work\fpga\opensource_hardware\Firmware\HMD\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_adc.c
#    Command line =  
#        D:\work\fpga\opensource_hardware\Firmware\HMD\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_adc.c
#        -D USE_STDPERIPH_DRIVER -D STM32F40_41xxx -D USE_STM324xG_EVAL -D
#        USE_USB_OTG_FS -lcN
#        D:\work\fpga\opensource_hardware\Firmware\HMD\Project\hr_mk1_hmd\CustomHID\EWARM\STM324xG-EVAL_USBD-FS\List\
#        -o
#        D:\work\fpga\opensource_hardware\Firmware\HMD\Project\hr_mk1_hmd\CustomHID\EWARM\STM324xG-EVAL_USBD-FS\Obj\
#        --debug --endian=little --cpu=Cortex-M4F -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0_2\arm\INC\c\DLib_Config_Full.h" -I
#        D:\work\fpga\opensource_hardware\Firmware\HMD\Project\hr_mk1_hmd\CustomHID\EWARM\..\
#        -I
#        D:\work\fpga\opensource_hardware\Firmware\HMD\Project\hr_mk1_hmd\CustomHID\EWARM\..\inc\
#        -I
#        D:\work\fpga\opensource_hardware\Firmware\HMD\Project\hr_mk1_hmd\CustomHID\EWARM\..\..\..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include\
#        -I
#        D:\work\fpga\opensource_hardware\Firmware\HMD\Project\hr_mk1_hmd\CustomHID\EWARM\..\..\..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\
#        -I
#        D:\work\fpga\opensource_hardware\Firmware\HMD\Project\hr_mk1_hmd\CustomHID\EWARM\..\..\..\..\Libraries\STM32_USB_OTG_Driver\inc\
#        -I
#        D:\work\fpga\opensource_hardware\Firmware\HMD\Project\hr_mk1_hmd\CustomHID\EWARM\..\..\..\..\Libraries\STM32_USB_Device_Library\Core\inc\
#        -I
#        D:\work\fpga\opensource_hardware\Firmware\HMD\Project\hr_mk1_hmd\CustomHID\EWARM\..\..\..\..\Libraries\STM32_USB_Device_Library\Class\customhid\inc\
#        -I
#        D:\work\fpga\opensource_hardware\Firmware\HMD\Project\hr_mk1_hmd\CustomHID\EWARM\..\..\..\..\Utilities\STM32_EVAL\
#        -I
#        D:\work\fpga\opensource_hardware\Firmware\HMD\Project\hr_mk1_hmd\CustomHID\EWARM\..\..\..\..\Utilities\STM32_EVAL\Common\
#        -I
#        D:\work\fpga\opensource_hardware\Firmware\HMD\Project\hr_mk1_hmd\CustomHID\EWARM\..\..\..\..\Utilities\STM32_EVAL\STM3240_41_G_EVAL\
#        -Ohz --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0_2\arm\CMSIS\Include\"
#    List file    =  
#        D:\work\fpga\opensource_hardware\Firmware\HMD\Project\hr_mk1_hmd\CustomHID\EWARM\STM324xG-EVAL_USBD-FS\List\stm32f4xx_adc.lst
#    Object file  =  
#        D:\work\fpga\opensource_hardware\Firmware\HMD\Project\hr_mk1_hmd\CustomHID\EWARM\STM324xG-EVAL_USBD-FS\Obj\stm32f4xx_adc.o
#
###############################################################################

D:\work\fpga\opensource_hardware\Firmware\HMD\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_adc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_adc.c
      4            * @author  MCD Application Team
      5            * @version V1.6.0
      6            * @date    10-July-2015
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Analog to Digital Convertor (ADC) peripheral:
      9            *           + Initialization and Configuration (in addition to ADC multi mode 
     10            *             selection)
     11            *           + Analog Watchdog configuration
     12            *           + Temperature Sensor & Vrefint (Voltage Reference internal) & VBAT
     13            *             management 
     14            *           + Regular Channels Configuration
     15            *           + Regular Channels DMA Configuration
     16            *           + Injected channels Configuration
     17            *           + Interrupts and flags management
     18            *         
     19            @verbatim
     20           ===============================================================================
     21                               ##### How to use this driver #####
     22           ===============================================================================
     23              [..]
     24              (#) Enable the ADC interface clock using 
     25                  RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADCx, ENABLE); 
     26                 
     27              (#) ADC pins configuration
     28                   (++) Enable the clock for the ADC GPIOs using the following function:
     29                       RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOx, ENABLE);   
     30                   (++) Configure these ADC pins in analog mode using GPIO_Init();  
     31            
     32               (#) Configure the ADC Prescaler, conversion resolution and data 
     33                   alignment using the ADC_Init() function.
     34               (#) Activate the ADC peripheral using ADC_Cmd() function.
     35            
     36               *** Regular channels group configuration ***
     37               ============================================
     38               [..]    
     39                 (+) To configure the ADC regular channels group features, use 
     40                     ADC_Init() and ADC_RegularChannelConfig() functions.
     41                 (+) To activate the continuous mode, use the ADC_continuousModeCmd()
     42                     function.
     43                 (+) To configurate and activate the Discontinuous mode, use the 
     44                     ADC_DiscModeChannelCountConfig() and ADC_DiscModeCmd() functions.
     45                 (+) To read the ADC converted values, use the ADC_GetConversionValue()
     46                     function.
     47            
     48               *** Multi mode ADCs Regular channels configuration ***
     49               ======================================================
     50               [..]
     51                 (+) Refer to "Regular channels group configuration" description to
     52                     configure the ADC1, ADC2 and ADC3 regular channels.        
     53                 (+) Select the Multi mode ADC regular channels features (dual or 
     54                     triple mode) using ADC_CommonInit() function and configure 
     55                     the DMA mode using ADC_MultiModeDMARequestAfterLastTransferCmd() 
     56                     functions.        
     57                 (+) Read the ADCs converted values using the 
     58                     ADC_GetMultiModeConversionValue() function.
     59            
     60               *** DMA for Regular channels group features configuration ***
     61               ============================================================= 
     62               [..]
     63                 (+) To enable the DMA mode for regular channels group, use the 
     64                     ADC_DMACmd() function.
     65                 (+) To enable the generation of DMA requests continuously at the end
     66                     of the last DMA transfer, use the ADC_DMARequestAfterLastTransferCmd() 
     67                     function.
     68            
     69               *** Injected channels group configuration ***
     70               =============================================    
     71               [..]
     72                 (+) To configure the ADC Injected channels group features, use 
     73                     ADC_InjectedChannelConfig() and  ADC_InjectedSequencerLengthConfig()
     74                     functions.
     75                 (+) To activate the continuous mode, use the ADC_continuousModeCmd()
     76                     function.
     77                 (+) To activate the Injected Discontinuous mode, use the 
     78                     ADC_InjectedDiscModeCmd() function.  
     79                 (+) To activate the AutoInjected mode, use the ADC_AutoInjectedConvCmd() 
     80                     function.        
     81                 (+) To read the ADC converted values, use the ADC_GetInjectedConversionValue() 
     82                     function.
     83            
     84              @endverbatim
     85            ******************************************************************************
     86            * @attention
     87            *
     88            * <h2><center>&copy; COPYRIGHT 2015 STMicroelectronics</center></h2>
     89            *
     90            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     91            * You may not use this file except in compliance with the License.
     92            * You may obtain a copy of the License at:
     93            *
     94            *        http://www.st.com/software_license_agreement_liberty_v2
     95            *
     96            * Unless required by applicable law or agreed to in writing, software 
     97            * distributed under the License is distributed on an "AS IS" BASIS, 
     98            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     99            * See the License for the specific language governing permissions and
    100            * limitations under the License.
    101            *
    102            ******************************************************************************
    103            */ 
    104          
    105          /* Includes ------------------------------------------------------------------*/
    106          #include "stm32f4xx_adc.h"
    107          #include "stm32f4xx_rcc.h"
    108          
    109          /** @addtogroup STM32F4xx_StdPeriph_Driver
    110            * @{
    111            */
    112          
    113          /** @defgroup ADC 
    114            * @brief ADC driver modules
    115            * @{
    116            */ 
    117          
    118          /* Private typedef -----------------------------------------------------------*/
    119          /* Private define ------------------------------------------------------------*/ 
    120          
    121          /* ADC DISCNUM mask */
    122          #define CR1_DISCNUM_RESET         ((uint32_t)0xFFFF1FFF)
    123          
    124          /* ADC AWDCH mask */
    125          #define CR1_AWDCH_RESET           ((uint32_t)0xFFFFFFE0)   
    126          
    127          /* ADC Analog watchdog enable mode mask */
    128          #define CR1_AWDMode_RESET         ((uint32_t)0xFF3FFDFF)   
    129          
    130          /* CR1 register Mask */
    131          #define CR1_CLEAR_MASK            ((uint32_t)0xFCFFFEFF)
    132          
    133          /* ADC EXTEN mask */
    134          #define CR2_EXTEN_RESET           ((uint32_t)0xCFFFFFFF)  
    135          
    136          /* ADC JEXTEN mask */
    137          #define CR2_JEXTEN_RESET          ((uint32_t)0xFFCFFFFF)  
    138          
    139          /* ADC JEXTSEL mask */
    140          #define CR2_JEXTSEL_RESET         ((uint32_t)0xFFF0FFFF)  
    141          
    142          /* CR2 register Mask */
    143          #define CR2_CLEAR_MASK            ((uint32_t)0xC0FFF7FD)
    144          
    145          /* ADC SQx mask */
    146          #define SQR3_SQ_SET               ((uint32_t)0x0000001F)  
    147          #define SQR2_SQ_SET               ((uint32_t)0x0000001F)  
    148          #define SQR1_SQ_SET               ((uint32_t)0x0000001F)  
    149          
    150          /* ADC L Mask */
    151          #define SQR1_L_RESET              ((uint32_t)0xFF0FFFFF) 
    152          
    153          /* ADC JSQx mask */
    154          #define JSQR_JSQ_SET              ((uint32_t)0x0000001F) 
    155          
    156          /* ADC JL mask */
    157          #define JSQR_JL_SET               ((uint32_t)0x00300000) 
    158          #define JSQR_JL_RESET             ((uint32_t)0xFFCFFFFF) 
    159          
    160          /* ADC SMPx mask */
    161          #define SMPR1_SMP_SET             ((uint32_t)0x00000007)  
    162          #define SMPR2_SMP_SET             ((uint32_t)0x00000007) 
    163          
    164          /* ADC JDRx registers offset */
    165          #define JDR_OFFSET                ((uint8_t)0x28) 
    166          
    167          /* ADC CDR register base address */
    168          #define CDR_ADDRESS               ((uint32_t)0x40012308)   
    169          
    170          /* ADC CCR register Mask */
    171          #define CR_CLEAR_MASK             ((uint32_t)0xFFFC30E0)  
    172          
    173          /* Private macro -------------------------------------------------------------*/
    174          /* Private variables ---------------------------------------------------------*/
    175          /* Private function prototypes -----------------------------------------------*/
    176          /* Private functions ---------------------------------------------------------*/
    177          
    178          /** @defgroup ADC_Private_Functions
    179            * @{
    180            */ 
    181          
    182          /** @defgroup ADC_Group1 Initialization and Configuration functions
    183           *  @brief    Initialization and Configuration functions 
    184           *
    185          @verbatim    
    186           ===============================================================================
    187                        ##### Initialization and Configuration functions #####
    188           ===============================================================================
    189              [..]  This section provides functions allowing to:
    190                (+) Initialize and configure the ADC Prescaler
    191                (+) ADC Conversion Resolution (12bit..6bit)
    192                (+) Scan Conversion Mode (multichannel or one channel) for regular group
    193                (+) ADC Continuous Conversion Mode (Continuous or Single conversion) for 
    194                    regular group
    195                (+) External trigger Edge and source of regular group, 
    196                (+) Converted data alignment (left or right)
    197                (+) The number of ADC conversions that will be done using the sequencer for 
    198                    regular channel group
    199                (+) Multi ADC mode selection
    200                (+) Direct memory access mode selection for multi ADC mode  
    201                (+) Delay between 2 sampling phases (used in dual or triple interleaved modes)
    202                (+) Enable or disable the ADC peripheral   
    203          @endverbatim
    204            * @{
    205            */
    206          
    207          /**
    208            * @brief  Deinitializes all ADCs peripherals registers to their default reset 
    209            *         values.
    210            * @param  None
    211            * @retval None
    212            */
    213          void ADC_DeInit(void)
    214          {
    215            /* Enable all ADCs reset state */
    216            RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC, ENABLE);
    217            
    218            /* Release all ADCs from reset state */
    219            RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC, DISABLE);
    220          }
    221          
    222          /**
    223            * @brief  Initializes the ADCx peripheral according to the specified parameters 
    224            *         in the ADC_InitStruct.
    225            * @note   This function is used to configure the global features of the ADC ( 
    226            *         Resolution and Data Alignment), however, the rest of the configuration
    227            *         parameters are specific to the regular channels group (scan mode 
    228            *         activation, continuous mode activation, External trigger source and 
    229            *         edge, number of conversion in the regular channels group sequencer).  
    230            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    231            * @param  ADC_InitStruct: pointer to an ADC_InitTypeDef structure that contains
    232            *         the configuration information for the specified ADC peripheral.
    233            * @retval None
    234            */
    235          void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)
    236          {
    237            uint32_t tmpreg1 = 0;
    238            uint8_t tmpreg2 = 0;
    239            /* Check the parameters */
    240            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    241            assert_param(IS_ADC_RESOLUTION(ADC_InitStruct->ADC_Resolution)); 
    242            assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ScanConvMode));
    243            assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ContinuousConvMode)); 
    244            assert_param(IS_ADC_EXT_TRIG_EDGE(ADC_InitStruct->ADC_ExternalTrigConvEdge)); 
    245            assert_param(IS_ADC_EXT_TRIG(ADC_InitStruct->ADC_ExternalTrigConv));    
    246            assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign)); 
    247            assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfConversion));
    248            
    249            /*---------------------------- ADCx CR1 Configuration -----------------*/
    250            /* Get the ADCx CR1 value */
    251            tmpreg1 = ADCx->CR1;
    252            
    253            /* Clear RES and SCAN bits */
    254            tmpreg1 &= CR1_CLEAR_MASK;
    255            
    256            /* Configure ADCx: scan conversion mode and resolution */
    257            /* Set SCAN bit according to ADC_ScanConvMode value */
    258            /* Set RES bit according to ADC_Resolution value */ 
    259            tmpreg1 |= (uint32_t)(((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8) | \
    260                                             ADC_InitStruct->ADC_Resolution);
    261            /* Write to ADCx CR1 */
    262            ADCx->CR1 = tmpreg1;
    263            /*---------------------------- ADCx CR2 Configuration -----------------*/
    264            /* Get the ADCx CR2 value */
    265            tmpreg1 = ADCx->CR2;
    266            
    267            /* Clear CONT, ALIGN, EXTEN and EXTSEL bits */
    268            tmpreg1 &= CR2_CLEAR_MASK;
    269            
    270            /* Configure ADCx: external trigger event and edge, data alignment and 
    271               continuous conversion mode */
    272            /* Set ALIGN bit according to ADC_DataAlign value */
    273            /* Set EXTEN bits according to ADC_ExternalTrigConvEdge value */ 
    274            /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
    275            /* Set CONT bit according to ADC_ContinuousConvMode value */
    276            tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | \
    277                                  ADC_InitStruct->ADC_ExternalTrigConv | 
    278                                  ADC_InitStruct->ADC_ExternalTrigConvEdge | \
    279                                  ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));
    280                                  
    281            /* Write to ADCx CR2 */
    282            ADCx->CR2 = tmpreg1;
    283            /*---------------------------- ADCx SQR1 Configuration -----------------*/
    284            /* Get the ADCx SQR1 value */
    285            tmpreg1 = ADCx->SQR1;
    286            
    287            /* Clear L bits */
    288            tmpreg1 &= SQR1_L_RESET;
    289            
    290            /* Configure ADCx: regular channel sequence length */
    291            /* Set L bits according to ADC_NbrOfConversion value */
    292            tmpreg2 |= (uint8_t)(ADC_InitStruct->ADC_NbrOfConversion - (uint8_t)1);
    293            tmpreg1 |= ((uint32_t)tmpreg2 << 20);
    294            
    295            /* Write to ADCx SQR1 */
    296            ADCx->SQR1 = tmpreg1;
    297          }
    298          
    299          /**
    300            * @brief  Fills each ADC_InitStruct member with its default value.
    301            * @note   This function is used to initialize the global features of the ADC ( 
    302            *         Resolution and Data Alignment), however, the rest of the configuration
    303            *         parameters are specific to the regular channels group (scan mode 
    304            *         activation, continuous mode activation, External trigger source and 
    305            *         edge, number of conversion in the regular channels group sequencer).  
    306            * @param  ADC_InitStruct: pointer to an ADC_InitTypeDef structure which will 
    307            *         be initialized.
    308            * @retval None
    309            */
    310          void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
    311          {
    312            /* Initialize the ADC_Mode member */
    313            ADC_InitStruct->ADC_Resolution = ADC_Resolution_12b;
    314          
    315            /* initialize the ADC_ScanConvMode member */
    316            ADC_InitStruct->ADC_ScanConvMode = DISABLE;
    317          
    318            /* Initialize the ADC_ContinuousConvMode member */
    319            ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;
    320          
    321            /* Initialize the ADC_ExternalTrigConvEdge member */
    322            ADC_InitStruct->ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
    323          
    324            /* Initialize the ADC_ExternalTrigConv member */
    325            ADC_InitStruct->ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
    326          
    327            /* Initialize the ADC_DataAlign member */
    328            ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;
    329          
    330            /* Initialize the ADC_NbrOfConversion member */
    331            ADC_InitStruct->ADC_NbrOfConversion = 1;
    332          }
    333          
    334          /**
    335            * @brief  Initializes the ADCs peripherals according to the specified parameters 
    336            *         in the ADC_CommonInitStruct.
    337            * @param  ADC_CommonInitStruct: pointer to an ADC_CommonInitTypeDef structure 
    338            *         that contains the configuration information for  All ADCs peripherals.
    339            * @retval None
    340            */
    341          void ADC_CommonInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct)
    342          {
    343            uint32_t tmpreg1 = 0;
    344            /* Check the parameters */
    345            assert_param(IS_ADC_MODE(ADC_CommonInitStruct->ADC_Mode));
    346            assert_param(IS_ADC_PRESCALER(ADC_CommonInitStruct->ADC_Prescaler));
    347            assert_param(IS_ADC_DMA_ACCESS_MODE(ADC_CommonInitStruct->ADC_DMAAccessMode));
    348            assert_param(IS_ADC_SAMPLING_DELAY(ADC_CommonInitStruct->ADC_TwoSamplingDelay));
    349            /*---------------------------- ADC CCR Configuration -----------------*/
    350            /* Get the ADC CCR value */
    351            tmpreg1 = ADC->CCR;
    352            
    353            /* Clear MULTI, DELAY, DMA and ADCPRE bits */
    354            tmpreg1 &= CR_CLEAR_MASK;
    355            
    356            /* Configure ADCx: Multi mode, Delay between two sampling time, ADC prescaler,
    357               and DMA access mode for multimode */
    358            /* Set MULTI bits according to ADC_Mode value */
    359            /* Set ADCPRE bits according to ADC_Prescaler value */
    360            /* Set DMA bits according to ADC_DMAAccessMode value */
    361            /* Set DELAY bits according to ADC_TwoSamplingDelay value */    
    362            tmpreg1 |= (uint32_t)(ADC_CommonInitStruct->ADC_Mode | 
    363                                  ADC_CommonInitStruct->ADC_Prescaler | 
    364                                  ADC_CommonInitStruct->ADC_DMAAccessMode | 
    365                                  ADC_CommonInitStruct->ADC_TwoSamplingDelay);
    366                                  
    367            /* Write to ADC CCR */
    368            ADC->CCR = tmpreg1;
    369          }
    370          
    371          /**
    372            * @brief  Fills each ADC_CommonInitStruct member with its default value.
    373            * @param  ADC_CommonInitStruct: pointer to an ADC_CommonInitTypeDef structure
    374            *         which will be initialized.
    375            * @retval None
    376            */
    377          void ADC_CommonStructInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct)
    378          {
    379            /* Initialize the ADC_Mode member */
    380            ADC_CommonInitStruct->ADC_Mode = ADC_Mode_Independent;
    381          
    382            /* initialize the ADC_Prescaler member */
    383            ADC_CommonInitStruct->ADC_Prescaler = ADC_Prescaler_Div2;
    384          
    385            /* Initialize the ADC_DMAAccessMode member */
    386            ADC_CommonInitStruct->ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled;
    387          
    388            /* Initialize the ADC_TwoSamplingDelay member */
    389            ADC_CommonInitStruct->ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_5Cycles;
    390          }
    391          
    392          /**
    393            * @brief  Enables or disables the specified ADC peripheral.
    394            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    395            * @param  NewState: new state of the ADCx peripheral. 
    396            *          This parameter can be: ENABLE or DISABLE.
    397            * @retval None
    398            */
    399          void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    400          {
    401            /* Check the parameters */
    402            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    403            assert_param(IS_FUNCTIONAL_STATE(NewState));
    404            if (NewState != DISABLE)
    405            {
    406              /* Set the ADON bit to wake up the ADC from power down mode */
    407              ADCx->CR2 |= (uint32_t)ADC_CR2_ADON;
    408            }
    409            else
    410            {
    411              /* Disable the selected ADC peripheral */
    412              ADCx->CR2 &= (uint32_t)(~ADC_CR2_ADON);
    413            }
    414          }
    415          /**
    416            * @}
    417            */
    418          
    419          /** @defgroup ADC_Group2 Analog Watchdog configuration functions
    420           *  @brief    Analog Watchdog configuration functions 
    421           *
    422          @verbatim   
    423           ===============================================================================
    424                       ##### Analog Watchdog configuration functions #####
    425           ===============================================================================  
    426              [..] This section provides functions allowing to configure the Analog Watchdog
    427                   (AWD) feature in the ADC.
    428            
    429              [..] A typical configuration Analog Watchdog is done following these steps :
    430                (#) the ADC guarded channel(s) is (are) selected using the 
    431                    ADC_AnalogWatchdogSingleChannelConfig() function.
    432                (#) The Analog watchdog lower and higher threshold are configured using the  
    433                    ADC_AnalogWatchdogThresholdsConfig() function.
    434                (#) The Analog watchdog is enabled and configured to enable the check, on one
    435                    or more channels, using the  ADC_AnalogWatchdogCmd() function.
    436          @endverbatim
    437            * @{
    438            */
    439            
    440          /**
    441            * @brief  Enables or disables the analog watchdog on single/all regular or 
    442            *         injected channels
    443            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    444            * @param  ADC_AnalogWatchdog: the ADC analog watchdog configuration.
    445            *         This parameter can be one of the following values:
    446            *            @arg ADC_AnalogWatchdog_SingleRegEnable: Analog watchdog on a single regular channel
    447            *            @arg ADC_AnalogWatchdog_SingleInjecEnable: Analog watchdog on a single injected channel
    448            *            @arg ADC_AnalogWatchdog_SingleRegOrInjecEnable: Analog watchdog on a single regular or injected channel
    449            *            @arg ADC_AnalogWatchdog_AllRegEnable: Analog watchdog on all regular channel
    450            *            @arg ADC_AnalogWatchdog_AllInjecEnable: Analog watchdog on all injected channel
    451            *            @arg ADC_AnalogWatchdog_AllRegAllInjecEnable: Analog watchdog on all regular and injected channels
    452            *            @arg ADC_AnalogWatchdog_None: No channel guarded by the analog watchdog
    453            * @retval None	  
    454            */
    455          void ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, uint32_t ADC_AnalogWatchdog)
    456          {
    457            uint32_t tmpreg = 0;
    458            /* Check the parameters */
    459            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    460            assert_param(IS_ADC_ANALOG_WATCHDOG(ADC_AnalogWatchdog));
    461            
    462            /* Get the old register value */
    463            tmpreg = ADCx->CR1;
    464            
    465            /* Clear AWDEN, JAWDEN and AWDSGL bits */
    466            tmpreg &= CR1_AWDMode_RESET;
    467            
    468            /* Set the analog watchdog enable mode */
    469            tmpreg |= ADC_AnalogWatchdog;
    470            
    471            /* Store the new register value */
    472            ADCx->CR1 = tmpreg;
    473          }
    474          
    475          /**
    476            * @brief  Configures the high and low thresholds of the analog watchdog.
    477            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    478            * @param  HighThreshold: the ADC analog watchdog High threshold value.
    479            *          This parameter must be a 12-bit value.
    480            * @param  LowThreshold:  the ADC analog watchdog Low threshold value.
    481            *          This parameter must be a 12-bit value.
    482            * @retval None
    483            */
    484          void ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, uint16_t HighThreshold,
    485                                                  uint16_t LowThreshold)
    486          {
    487            /* Check the parameters */
    488            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    489            assert_param(IS_ADC_THRESHOLD(HighThreshold));
    490            assert_param(IS_ADC_THRESHOLD(LowThreshold));
    491            
    492            /* Set the ADCx high threshold */
    493            ADCx->HTR = HighThreshold;
    494            
    495            /* Set the ADCx low threshold */
    496            ADCx->LTR = LowThreshold;
    497          }
    498          
    499          /**
    500            * @brief  Configures the analog watchdog guarded single channel
    501            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    502            * @param  ADC_Channel: the ADC channel to configure for the analog watchdog. 
    503            *          This parameter can be one of the following values:
    504            *            @arg ADC_Channel_0: ADC Channel0 selected
    505            *            @arg ADC_Channel_1: ADC Channel1 selected
    506            *            @arg ADC_Channel_2: ADC Channel2 selected
    507            *            @arg ADC_Channel_3: ADC Channel3 selected
    508            *            @arg ADC_Channel_4: ADC Channel4 selected
    509            *            @arg ADC_Channel_5: ADC Channel5 selected
    510            *            @arg ADC_Channel_6: ADC Channel6 selected
    511            *            @arg ADC_Channel_7: ADC Channel7 selected
    512            *            @arg ADC_Channel_8: ADC Channel8 selected
    513            *            @arg ADC_Channel_9: ADC Channel9 selected
    514            *            @arg ADC_Channel_10: ADC Channel10 selected
    515            *            @arg ADC_Channel_11: ADC Channel11 selected
    516            *            @arg ADC_Channel_12: ADC Channel12 selected
    517            *            @arg ADC_Channel_13: ADC Channel13 selected
    518            *            @arg ADC_Channel_14: ADC Channel14 selected
    519            *            @arg ADC_Channel_15: ADC Channel15 selected
    520            *            @arg ADC_Channel_16: ADC Channel16 selected
    521            *            @arg ADC_Channel_17: ADC Channel17 selected
    522            *            @arg ADC_Channel_18: ADC Channel18 selected
    523            * @retval None
    524            */
    525          void ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel)
    526          {
    527            uint32_t tmpreg = 0;
    528            /* Check the parameters */
    529            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    530            assert_param(IS_ADC_CHANNEL(ADC_Channel));
    531            
    532            /* Get the old register value */
    533            tmpreg = ADCx->CR1;
    534            
    535            /* Clear the Analog watchdog channel select bits */
    536            tmpreg &= CR1_AWDCH_RESET;
    537            
    538            /* Set the Analog watchdog channel */
    539            tmpreg |= ADC_Channel;
    540            
    541            /* Store the new register value */
    542            ADCx->CR1 = tmpreg;
    543          }
    544          /**
    545            * @}
    546            */
    547          
    548          /** @defgroup ADC_Group3 Temperature Sensor, Vrefint (Voltage Reference internal) 
    549           *            and VBAT (Voltage BATtery) management functions
    550           *  @brief   Temperature Sensor, Vrefint and VBAT management functions 
    551           *
    552          @verbatim   
    553           ===============================================================================
    554                ##### Temperature Sensor, Vrefint and VBAT management functions #####
    555           ===============================================================================  
    556              [..] This section provides functions allowing to enable/ disable the internal 
    557                   connections between the ADC and the Temperature Sensor, the Vrefint and 
    558                   the Vbat sources.
    559               
    560              [..] A typical configuration to get the Temperature sensor and Vrefint channels 
    561                   voltages is done following these steps :
    562                (#) Enable the internal connection of Temperature sensor and Vrefint sources 
    563                    with the ADC channels using ADC_TempSensorVrefintCmd() function. 
    564                (#) Select the ADC_Channel_TempSensor and/or ADC_Channel_Vrefint using 
    565                    ADC_RegularChannelConfig() or  ADC_InjectedChannelConfig() functions 
    566                (#) Get the voltage values, using ADC_GetConversionValue() or  
    567                    ADC_GetInjectedConversionValue().
    568          
    569              [..] A typical configuration to get the VBAT channel voltage is done following 
    570                   these steps :
    571                (#) Enable the internal connection of VBAT source with the ADC channel using 
    572                    ADC_VBATCmd() function. 
    573                (#) Select the ADC_Channel_Vbat using ADC_RegularChannelConfig() or  
    574                    ADC_InjectedChannelConfig() functions 
    575                (#) Get the voltage value, using ADC_GetConversionValue() or  
    576                    ADC_GetInjectedConversionValue().
    577           
    578          @endverbatim
    579            * @{
    580            */
    581            
    582            
    583          /**
    584            * @brief  Enables or disables the temperature sensor and Vrefint channels.
    585            * @param  NewState: new state of the temperature sensor and Vrefint channels.
    586            *          This parameter can be: ENABLE or DISABLE.
    587            * @retval None
    588            */
    589          void ADC_TempSensorVrefintCmd(FunctionalState NewState)                
    590          {
    591            /* Check the parameters */
    592            assert_param(IS_FUNCTIONAL_STATE(NewState));
    593            if (NewState != DISABLE)
    594            {
    595              /* Enable the temperature sensor and Vrefint channel*/
    596              ADC->CCR |= (uint32_t)ADC_CCR_TSVREFE;
    597            }
    598            else
    599            {
    600              /* Disable the temperature sensor and Vrefint channel*/
    601              ADC->CCR &= (uint32_t)(~ADC_CCR_TSVREFE);
    602            }
    603          }
    604          
    605          /**
    606            * @brief  Enables or disables the VBAT (Voltage Battery) channel.
    607            * 
    608            * @note   the Battery voltage measured is equal to VBAT/2 on STM32F40xx and 
    609            *         STM32F41xx devices and equal to VBAT/4 on STM32F42xx and STM32F43xx devices 
    610            *              
    611            * @param  NewState: new state of the VBAT channel.
    612            *          This parameter can be: ENABLE or DISABLE.
    613            * @retval None
    614            */
    615          void ADC_VBATCmd(FunctionalState NewState)                             
    616          {
    617            /* Check the parameters */
    618            assert_param(IS_FUNCTIONAL_STATE(NewState));
    619            if (NewState != DISABLE)
    620            {
    621              /* Enable the VBAT channel*/
    622              ADC->CCR |= (uint32_t)ADC_CCR_VBATE;
    623            }
    624            else
    625            {
    626              /* Disable the VBAT channel*/
    627              ADC->CCR &= (uint32_t)(~ADC_CCR_VBATE);
    628            }
    629          }
    630          
    631          /**
    632            * @}
    633            */
    634          
    635          /** @defgroup ADC_Group4 Regular Channels Configuration functions
    636           *  @brief   Regular Channels Configuration functions 
    637           *
    638          @verbatim   
    639           ===============================================================================
    640                       ##### Regular Channels Configuration functions #####
    641           ===============================================================================  
    642          
    643              [..] This section provides functions allowing to manage the ADC's regular channels,
    644                   it is composed of 2 sub sections : 
    645            
    646                (#) Configuration and management functions for regular channels: This subsection 
    647                    provides functions allowing to configure the ADC regular channels :    
    648                   (++) Configure the rank in the regular group sequencer for each channel
    649                   (++) Configure the sampling time for each channel
    650                   (++) select the conversion Trigger for regular channels
    651                   (++) select the desired EOC event behavior configuration
    652                   (++) Activate the continuous Mode  (*)
    653                   (++) Activate the Discontinuous Mode 
    654                   -@@- Please Note that the following features for regular channels 
    655                       are configured using the ADC_Init() function : 
    656                     (+@@) scan mode activation 
    657                     (+@@) continuous mode activation (**) 
    658                     (+@@) External trigger source  
    659                     (+@@) External trigger edge 
    660                     (+@@) number of conversion in the regular channels group sequencer.
    661               
    662                   -@@- (*) and (**) are performing the same configuration
    663               
    664                (#) Get the conversion data: This subsection provides an important function in 
    665                    the ADC peripheral since it returns the converted data of the current 
    666                    regular channel. When the Conversion value is read, the EOC Flag is 
    667                    automatically cleared.
    668               
    669                    -@- For multi ADC mode, the last ADC1, ADC2 and ADC3 regular conversions 
    670                        results data (in the selected multi mode) can be returned in the same 
    671                        time using ADC_GetMultiModeConversionValue() function. 
    672                   
    673          @endverbatim
    674            * @{
    675            */
    676          /**
    677            * @brief  Configures for the selected ADC regular channel its corresponding
    678            *         rank in the sequencer and its sample time.
    679            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    680            * @param  ADC_Channel: the ADC channel to configure. 
    681            *          This parameter can be one of the following values:
    682            *            @arg ADC_Channel_0: ADC Channel0 selected
    683            *            @arg ADC_Channel_1: ADC Channel1 selected
    684            *            @arg ADC_Channel_2: ADC Channel2 selected
    685            *            @arg ADC_Channel_3: ADC Channel3 selected
    686            *            @arg ADC_Channel_4: ADC Channel4 selected
    687            *            @arg ADC_Channel_5: ADC Channel5 selected
    688            *            @arg ADC_Channel_6: ADC Channel6 selected
    689            *            @arg ADC_Channel_7: ADC Channel7 selected
    690            *            @arg ADC_Channel_8: ADC Channel8 selected
    691            *            @arg ADC_Channel_9: ADC Channel9 selected
    692            *            @arg ADC_Channel_10: ADC Channel10 selected
    693            *            @arg ADC_Channel_11: ADC Channel11 selected
    694            *            @arg ADC_Channel_12: ADC Channel12 selected
    695            *            @arg ADC_Channel_13: ADC Channel13 selected
    696            *            @arg ADC_Channel_14: ADC Channel14 selected
    697            *            @arg ADC_Channel_15: ADC Channel15 selected
    698            *            @arg ADC_Channel_16: ADC Channel16 selected
    699            *            @arg ADC_Channel_17: ADC Channel17 selected
    700            *            @arg ADC_Channel_18: ADC Channel18 selected                       
    701            * @param  Rank: The rank in the regular group sequencer.
    702            *          This parameter must be between 1 to 16.
    703            * @param  ADC_SampleTime: The sample time value to be set for the selected channel. 
    704            *          This parameter can be one of the following values:
    705            *            @arg ADC_SampleTime_3Cycles: Sample time equal to 3 cycles
    706            *            @arg ADC_SampleTime_15Cycles: Sample time equal to 15 cycles
    707            *            @arg ADC_SampleTime_28Cycles: Sample time equal to 28 cycles
    708            *            @arg ADC_SampleTime_56Cycles: Sample time equal to 56 cycles	
    709            *            @arg ADC_SampleTime_84Cycles: Sample time equal to 84 cycles	
    710            *            @arg ADC_SampleTime_112Cycles: Sample time equal to 112 cycles	
    711            *            @arg ADC_SampleTime_144Cycles: Sample time equal to 144 cycles	
    712            *            @arg ADC_SampleTime_480Cycles: Sample time equal to 480 cycles	
    713            * @retval None
    714            */
    715          void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
    716          {
    717            uint32_t tmpreg1 = 0, tmpreg2 = 0;
    718            /* Check the parameters */
    719            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    720            assert_param(IS_ADC_CHANNEL(ADC_Channel));
    721            assert_param(IS_ADC_REGULAR_RANK(Rank));
    722            assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
    723            
    724            /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
    725            if (ADC_Channel > ADC_Channel_9)
    726            {
    727              /* Get the old register value */
    728              tmpreg1 = ADCx->SMPR1;
    729              
    730              /* Calculate the mask to clear */
    731              tmpreg2 = SMPR1_SMP_SET << (3 * (ADC_Channel - 10));
    732              
    733              /* Clear the old sample time */
    734              tmpreg1 &= ~tmpreg2;
    735              
    736              /* Calculate the mask to set */
    737              tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
    738              
    739              /* Set the new sample time */
    740              tmpreg1 |= tmpreg2;
    741              
    742              /* Store the new register value */
    743              ADCx->SMPR1 = tmpreg1;
    744            }
    745            else /* ADC_Channel include in ADC_Channel_[0..9] */
    746            {
    747              /* Get the old register value */
    748              tmpreg1 = ADCx->SMPR2;
    749              
    750              /* Calculate the mask to clear */
    751              tmpreg2 = SMPR2_SMP_SET << (3 * ADC_Channel);
    752              
    753              /* Clear the old sample time */
    754              tmpreg1 &= ~tmpreg2;
    755              
    756              /* Calculate the mask to set */
    757              tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
    758              
    759              /* Set the new sample time */
    760              tmpreg1 |= tmpreg2;
    761              
    762              /* Store the new register value */
    763              ADCx->SMPR2 = tmpreg1;
    764            }
    765            /* For Rank 1 to 6 */
    766            if (Rank < 7)
    767            {
    768              /* Get the old register value */
    769              tmpreg1 = ADCx->SQR3;
    770              
    771              /* Calculate the mask to clear */
    772              tmpreg2 = SQR3_SQ_SET << (5 * (Rank - 1));
    773              
    774              /* Clear the old SQx bits for the selected rank */
    775              tmpreg1 &= ~tmpreg2;
    776              
    777              /* Calculate the mask to set */
    778              tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 1));
    779              
    780              /* Set the SQx bits for the selected rank */
    781              tmpreg1 |= tmpreg2;
    782              
    783              /* Store the new register value */
    784              ADCx->SQR3 = tmpreg1;
    785            }
    786            /* For Rank 7 to 12 */
    787            else if (Rank < 13)
    788            {
    789              /* Get the old register value */
    790              tmpreg1 = ADCx->SQR2;
    791              
    792              /* Calculate the mask to clear */
    793              tmpreg2 = SQR2_SQ_SET << (5 * (Rank - 7));
    794              
    795              /* Clear the old SQx bits for the selected rank */
    796              tmpreg1 &= ~tmpreg2;
    797              
    798              /* Calculate the mask to set */
    799              tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 7));
    800              
    801              /* Set the SQx bits for the selected rank */
    802              tmpreg1 |= tmpreg2;
    803              
    804              /* Store the new register value */
    805              ADCx->SQR2 = tmpreg1;
    806            }
    807            /* For Rank 13 to 16 */
    808            else
    809            {
    810              /* Get the old register value */
    811              tmpreg1 = ADCx->SQR1;
    812              
    813              /* Calculate the mask to clear */
    814              tmpreg2 = SQR1_SQ_SET << (5 * (Rank - 13));
    815              
    816              /* Clear the old SQx bits for the selected rank */
    817              tmpreg1 &= ~tmpreg2;
    818              
    819              /* Calculate the mask to set */
    820              tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 13));
    821              
    822              /* Set the SQx bits for the selected rank */
    823              tmpreg1 |= tmpreg2;
    824              
    825              /* Store the new register value */
    826              ADCx->SQR1 = tmpreg1;
    827            }
    828          }
    829          
    830          /**
    831            * @brief  Enables the selected ADC software start conversion of the regular channels.
    832            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    833            * @retval None
    834            */
    835          void ADC_SoftwareStartConv(ADC_TypeDef* ADCx)
    836          {
    837            /* Check the parameters */
    838            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    839            
    840            /* Enable the selected ADC conversion for regular group */
    841            ADCx->CR2 |= (uint32_t)ADC_CR2_SWSTART;
    842          }
    843          
    844          /**
    845            * @brief  Gets the selected ADC Software start regular conversion Status.
    846            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    847            * @retval The new state of ADC software start conversion (SET or RESET).
    848            */
    849          FlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx)
    850          {
    851            FlagStatus bitstatus = RESET;
    852            /* Check the parameters */
    853            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    854            
    855            /* Check the status of SWSTART bit */
    856            if ((ADCx->CR2 & ADC_CR2_SWSTART) != (uint32_t)RESET)
    857            {
    858              /* SWSTART bit is set */
    859              bitstatus = SET;
    860            }
    861            else
    862            {
    863              /* SWSTART bit is reset */
    864              bitstatus = RESET;
    865            }
    866            
    867            /* Return the SWSTART bit status */
    868            return  bitstatus;
    869          }
    870          
    871          
    872          /**
    873            * @brief  Enables or disables the EOC on each regular channel conversion
    874            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    875            * @param  NewState: new state of the selected ADC EOC flag rising
    876            *          This parameter can be: ENABLE or DISABLE.
    877            * @retval None
    878            */
    879          void ADC_EOCOnEachRegularChannelCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    880          {
    881            /* Check the parameters */
    882            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    883            assert_param(IS_FUNCTIONAL_STATE(NewState));
    884            
    885            if (NewState != DISABLE)
    886            {
    887              /* Enable the selected ADC EOC rising on each regular channel conversion */
    888              ADCx->CR2 |= (uint32_t)ADC_CR2_EOCS;
    889            }
    890            else
    891            {
    892              /* Disable the selected ADC EOC rising on each regular channel conversion */
    893              ADCx->CR2 &= (uint32_t)(~ADC_CR2_EOCS);
    894            }
    895          }
    896          
    897          /**
    898            * @brief  Enables or disables the ADC continuous conversion mode 
    899            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    900            * @param  NewState: new state of the selected ADC continuous conversion mode
    901            *          This parameter can be: ENABLE or DISABLE.
    902            * @retval None
    903            */
    904          void ADC_ContinuousModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    905          {
    906            /* Check the parameters */
    907            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    908            assert_param(IS_FUNCTIONAL_STATE(NewState));
    909            
    910            if (NewState != DISABLE)
    911            {
    912              /* Enable the selected ADC continuous conversion mode */
    913              ADCx->CR2 |= (uint32_t)ADC_CR2_CONT;
    914            }
    915            else
    916            {
    917              /* Disable the selected ADC continuous conversion mode */
    918              ADCx->CR2 &= (uint32_t)(~ADC_CR2_CONT);
    919            }
    920          }
    921          
    922          /**
    923            * @brief  Configures the discontinuous mode for the selected ADC regular group 
    924            *         channel.
    925            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    926            * @param  Number: specifies the discontinuous mode regular channel count value.
    927            *          This number must be between 1 and 8.
    928            * @retval None
    929            */
    930          void ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, uint8_t Number)
    931          {
    932            uint32_t tmpreg1 = 0;
    933            uint32_t tmpreg2 = 0;
    934            
    935            /* Check the parameters */
    936            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    937            assert_param(IS_ADC_REGULAR_DISC_NUMBER(Number));
    938            
    939            /* Get the old register value */
    940            tmpreg1 = ADCx->CR1;
    941            
    942            /* Clear the old discontinuous mode channel count */
    943            tmpreg1 &= CR1_DISCNUM_RESET;
    944            
    945            /* Set the discontinuous mode channel count */
    946            tmpreg2 = Number - 1;
    947            tmpreg1 |= tmpreg2 << 13;
    948            
    949            /* Store the new register value */
    950            ADCx->CR1 = tmpreg1;
    951          }
    952          
    953          /**
    954            * @brief  Enables or disables the discontinuous mode on regular group channel 
    955            *         for the specified ADC
    956            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    957            * @param  NewState: new state of the selected ADC discontinuous mode on 
    958            *         regular group channel.
    959            *          This parameter can be: ENABLE or DISABLE.
    960            * @retval None
    961            */
    962          void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    963          {
    964            /* Check the parameters */
    965            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    966            assert_param(IS_FUNCTIONAL_STATE(NewState));
    967            
    968            if (NewState != DISABLE)
    969            {
    970              /* Enable the selected ADC regular discontinuous mode */
    971              ADCx->CR1 |= (uint32_t)ADC_CR1_DISCEN;
    972            }
    973            else
    974            {
    975              /* Disable the selected ADC regular discontinuous mode */
    976              ADCx->CR1 &= (uint32_t)(~ADC_CR1_DISCEN);
    977            }
    978          }
    979          
    980          /**
    981            * @brief  Returns the last ADCx conversion result data for regular channel.
    982            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    983            * @retval The Data conversion value.
    984            */
    985          uint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx)
    986          {
    987            /* Check the parameters */
    988            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    989            
    990            /* Return the selected ADC conversion value */
    991            return (uint16_t) ADCx->DR;
    992          }
    993          
    994          /**
    995            * @brief  Returns the last ADC1, ADC2 and ADC3 regular conversions results 
    996            *         data in the selected multi mode.
    997            * @param  None  
    998            * @retval The Data conversion value.
    999            * @note   In dual mode, the value returned by this function is as following
   1000            *           Data[15:0] : these bits contain the regular data of ADC1.
   1001            *           Data[31:16]: these bits contain the regular data of ADC2.
   1002            * @note   In triple mode, the value returned by this function is as following
   1003            *           Data[15:0] : these bits contain alternatively the regular data of ADC1, ADC3 and ADC2.
   1004            *           Data[31:16]: these bits contain alternatively the regular data of ADC2, ADC1 and ADC3.           
   1005            */
   1006          uint32_t ADC_GetMultiModeConversionValue(void)
   1007          {
   1008            /* Return the multi mode conversion value */
   1009            return (*(__IO uint32_t *) CDR_ADDRESS);
   1010          }
   1011          /**
   1012            * @}
   1013            */
   1014          
   1015          /** @defgroup ADC_Group5 Regular Channels DMA Configuration functions
   1016           *  @brief   Regular Channels DMA Configuration functions 
   1017           *
   1018          @verbatim   
   1019           ===============================================================================
   1020                      ##### Regular Channels DMA Configuration functions #####
   1021           ===============================================================================  
   1022              [..] This section provides functions allowing to configure the DMA for ADC 
   1023                   regular channels.
   1024                   Since converted regular channel values are stored into a unique data 
   1025                   register, it is useful to use DMA for conversion of more than one regular 
   1026                   channel. This avoids the loss of the data already stored in the ADC 
   1027                   Data register.   
   1028                   When the DMA mode is enabled (using the ADC_DMACmd() function), after each
   1029                   conversion of a regular channel, a DMA request is generated.
   1030              [..] Depending on the "DMA disable selection for Independent ADC mode" 
   1031                   configuration (using the ADC_DMARequestAfterLastTransferCmd() function), 
   1032                   at the end of the last DMA transfer, two possibilities are allowed:
   1033                (+) No new DMA request is issued to the DMA controller (feature DISABLED) 
   1034                (+) Requests can continue to be generated (feature ENABLED).  
   1035              [..] Depending on the "DMA disable selection for multi ADC mode" configuration 
   1036                   (using the void ADC_MultiModeDMARequestAfterLastTransferCmd() function), 
   1037                   at the end of the last DMA transfer, two possibilities are allowed:
   1038                  (+) No new DMA request is issued to the DMA controller (feature DISABLED) 
   1039                  (+) Requests can continue to be generated (feature ENABLED).
   1040          
   1041          @endverbatim
   1042            * @{
   1043            */
   1044            
   1045           /**
   1046            * @brief  Enables or disables the specified ADC DMA request.
   1047            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1048            * @param  NewState: new state of the selected ADC DMA transfer.
   1049            *          This parameter can be: ENABLE or DISABLE.
   1050            * @retval None
   1051            */
   1052          void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)
   1053          {
   1054            /* Check the parameters */
   1055            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1056            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1057            if (NewState != DISABLE)
   1058            {
   1059              /* Enable the selected ADC DMA request */
   1060              ADCx->CR2 |= (uint32_t)ADC_CR2_DMA;
   1061            }
   1062            else
   1063            {
   1064              /* Disable the selected ADC DMA request */
   1065              ADCx->CR2 &= (uint32_t)(~ADC_CR2_DMA);
   1066            }
   1067          }
   1068          
   1069          /**
   1070            * @brief  Enables or disables the ADC DMA request after last transfer (Single-ADC mode)  
   1071            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1072            * @param  NewState: new state of the selected ADC DMA request after last transfer.
   1073            *          This parameter can be: ENABLE or DISABLE.
   1074            * @retval None
   1075            */
   1076          void ADC_DMARequestAfterLastTransferCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
   1077          {
   1078            /* Check the parameters */
   1079            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1080            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1081            if (NewState != DISABLE)
   1082            {
   1083              /* Enable the selected ADC DMA request after last transfer */
   1084              ADCx->CR2 |= (uint32_t)ADC_CR2_DDS;
   1085            }
   1086            else
   1087            {
   1088              /* Disable the selected ADC DMA request after last transfer */
   1089              ADCx->CR2 &= (uint32_t)(~ADC_CR2_DDS);
   1090            }
   1091          }
   1092          
   1093          /**
   1094            * @brief  Enables or disables the ADC DMA request after last transfer in multi ADC mode       
   1095            * @param  NewState: new state of the selected ADC DMA request after last transfer.
   1096            *          This parameter can be: ENABLE or DISABLE.
   1097            * @note   if Enabled, DMA requests are issued as long as data are converted and 
   1098            *         DMA mode for multi ADC mode (selected using ADC_CommonInit() function 
   1099            *         by ADC_CommonInitStruct.ADC_DMAAccessMode structure member) is 
   1100            *          ADC_DMAAccessMode_1, ADC_DMAAccessMode_2 or ADC_DMAAccessMode_3.     
   1101            * @retval None
   1102            */
   1103          void ADC_MultiModeDMARequestAfterLastTransferCmd(FunctionalState NewState)
   1104          {
   1105            /* Check the parameters */
   1106            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1107            if (NewState != DISABLE)
   1108            {
   1109              /* Enable the selected ADC DMA request after last transfer */
   1110              ADC->CCR |= (uint32_t)ADC_CCR_DDS;
   1111            }
   1112            else
   1113            {
   1114              /* Disable the selected ADC DMA request after last transfer */
   1115              ADC->CCR &= (uint32_t)(~ADC_CCR_DDS);
   1116            }
   1117          }
   1118          /**
   1119            * @}
   1120            */
   1121          
   1122          /** @defgroup ADC_Group6 Injected channels Configuration functions
   1123           *  @brief   Injected channels Configuration functions 
   1124           *
   1125          @verbatim   
   1126           ===============================================================================
   1127                        ##### Injected channels Configuration functions #####
   1128           ===============================================================================  
   1129          
   1130              [..] This section provide functions allowing to configure the ADC Injected channels,
   1131                   it is composed of 2 sub sections : 
   1132              
   1133                (#) Configuration functions for Injected channels: This subsection provides 
   1134                    functions allowing to configure the ADC injected channels :    
   1135                  (++) Configure the rank in the injected group sequencer for each channel
   1136                  (++) Configure the sampling time for each channel    
   1137                  (++) Activate the Auto injected Mode  
   1138                  (++) Activate the Discontinuous Mode 
   1139                  (++) scan mode activation  
   1140                  (++) External/software trigger source   
   1141                  (++) External trigger edge 
   1142                  (++) injected channels sequencer.
   1143              
   1144                (#) Get the Specified Injected channel conversion data: This subsection 
   1145                    provides an important function in the ADC peripheral since it returns the 
   1146                    converted data of the specific injected channel.
   1147          
   1148          @endverbatim
   1149            * @{
   1150            */ 
   1151          /**
   1152            * @brief  Configures for the selected ADC injected channel its corresponding
   1153            *         rank in the sequencer and its sample time.
   1154            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1155            * @param  ADC_Channel: the ADC channel to configure. 
   1156            *          This parameter can be one of the following values:
   1157            *            @arg ADC_Channel_0: ADC Channel0 selected
   1158            *            @arg ADC_Channel_1: ADC Channel1 selected
   1159            *            @arg ADC_Channel_2: ADC Channel2 selected
   1160            *            @arg ADC_Channel_3: ADC Channel3 selected
   1161            *            @arg ADC_Channel_4: ADC Channel4 selected
   1162            *            @arg ADC_Channel_5: ADC Channel5 selected
   1163            *            @arg ADC_Channel_6: ADC Channel6 selected
   1164            *            @arg ADC_Channel_7: ADC Channel7 selected
   1165            *            @arg ADC_Channel_8: ADC Channel8 selected
   1166            *            @arg ADC_Channel_9: ADC Channel9 selected
   1167            *            @arg ADC_Channel_10: ADC Channel10 selected
   1168            *            @arg ADC_Channel_11: ADC Channel11 selected
   1169            *            @arg ADC_Channel_12: ADC Channel12 selected
   1170            *            @arg ADC_Channel_13: ADC Channel13 selected
   1171            *            @arg ADC_Channel_14: ADC Channel14 selected
   1172            *            @arg ADC_Channel_15: ADC Channel15 selected
   1173            *            @arg ADC_Channel_16: ADC Channel16 selected
   1174            *            @arg ADC_Channel_17: ADC Channel17 selected
   1175            *            @arg ADC_Channel_18: ADC Channel18 selected                       
   1176            * @param  Rank: The rank in the injected group sequencer. 
   1177            *          This parameter must be between 1 to 4.
   1178            * @param  ADC_SampleTime: The sample time value to be set for the selected channel. 
   1179            *          This parameter can be one of the following values:
   1180            *            @arg ADC_SampleTime_3Cycles: Sample time equal to 3 cycles
   1181            *            @arg ADC_SampleTime_15Cycles: Sample time equal to 15 cycles
   1182            *            @arg ADC_SampleTime_28Cycles: Sample time equal to 28 cycles
   1183            *            @arg ADC_SampleTime_56Cycles: Sample time equal to 56 cycles	
   1184            *            @arg ADC_SampleTime_84Cycles: Sample time equal to 84 cycles	
   1185            *            @arg ADC_SampleTime_112Cycles: Sample time equal to 112 cycles	
   1186            *            @arg ADC_SampleTime_144Cycles: Sample time equal to 144 cycles	
   1187            *            @arg ADC_SampleTime_480Cycles: Sample time equal to 480 cycles	
   1188            * @retval None
   1189            */
   1190          void ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
   1191          {
   1192            uint32_t tmpreg1 = 0, tmpreg2 = 0, tmpreg3 = 0;
   1193            /* Check the parameters */
   1194            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1195            assert_param(IS_ADC_CHANNEL(ADC_Channel));
   1196            assert_param(IS_ADC_INJECTED_RANK(Rank));
   1197            assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
   1198            /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
   1199            if (ADC_Channel > ADC_Channel_9)
   1200            {
   1201              /* Get the old register value */
   1202              tmpreg1 = ADCx->SMPR1;
   1203              /* Calculate the mask to clear */
   1204              tmpreg2 = SMPR1_SMP_SET << (3*(ADC_Channel - 10));
   1205              /* Clear the old sample time */
   1206              tmpreg1 &= ~tmpreg2;
   1207              /* Calculate the mask to set */
   1208              tmpreg2 = (uint32_t)ADC_SampleTime << (3*(ADC_Channel - 10));
   1209              /* Set the new sample time */
   1210              tmpreg1 |= tmpreg2;
   1211              /* Store the new register value */
   1212              ADCx->SMPR1 = tmpreg1;
   1213            }
   1214            else /* ADC_Channel include in ADC_Channel_[0..9] */
   1215            {
   1216              /* Get the old register value */
   1217              tmpreg1 = ADCx->SMPR2;
   1218              /* Calculate the mask to clear */
   1219              tmpreg2 = SMPR2_SMP_SET << (3 * ADC_Channel);
   1220              /* Clear the old sample time */
   1221              tmpreg1 &= ~tmpreg2;
   1222              /* Calculate the mask to set */
   1223              tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
   1224              /* Set the new sample time */
   1225              tmpreg1 |= tmpreg2;
   1226              /* Store the new register value */
   1227              ADCx->SMPR2 = tmpreg1;
   1228            }
   1229            /* Rank configuration */
   1230            /* Get the old register value */
   1231            tmpreg1 = ADCx->JSQR;
   1232            /* Get JL value: Number = JL+1 */
   1233            tmpreg3 =  (tmpreg1 & JSQR_JL_SET)>> 20;
   1234            /* Calculate the mask to clear: ((Rank-1)+(4-JL-1)) */
   1235            tmpreg2 = JSQR_JSQ_SET << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
   1236            /* Clear the old JSQx bits for the selected rank */
   1237            tmpreg1 &= ~tmpreg2;
   1238            /* Calculate the mask to set: ((Rank-1)+(4-JL-1)) */
   1239            tmpreg2 = (uint32_t)ADC_Channel << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
   1240            /* Set the JSQx bits for the selected rank */
   1241            tmpreg1 |= tmpreg2;
   1242            /* Store the new register value */
   1243            ADCx->JSQR = tmpreg1;
   1244          }
   1245          
   1246          /**
   1247            * @brief  Configures the sequencer length for injected channels
   1248            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1249            * @param  Length: The sequencer length. 
   1250            *          This parameter must be a number between 1 to 4.
   1251            * @retval None
   1252            */
   1253          void ADC_InjectedSequencerLengthConfig(ADC_TypeDef* ADCx, uint8_t Length)
   1254          {
   1255            uint32_t tmpreg1 = 0;
   1256            uint32_t tmpreg2 = 0;
   1257            /* Check the parameters */
   1258            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1259            assert_param(IS_ADC_INJECTED_LENGTH(Length));
   1260            
   1261            /* Get the old register value */
   1262            tmpreg1 = ADCx->JSQR;
   1263            
   1264            /* Clear the old injected sequence length JL bits */
   1265            tmpreg1 &= JSQR_JL_RESET;
   1266            
   1267            /* Set the injected sequence length JL bits */
   1268            tmpreg2 = Length - 1; 
   1269            tmpreg1 |= tmpreg2 << 20;
   1270            
   1271            /* Store the new register value */
   1272            ADCx->JSQR = tmpreg1;
   1273          }
   1274          
   1275          /**
   1276            * @brief  Set the injected channels conversion value offset
   1277            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1278            * @param  ADC_InjectedChannel: the ADC injected channel to set its offset. 
   1279            *          This parameter can be one of the following values:
   1280            *            @arg ADC_InjectedChannel_1: Injected Channel1 selected
   1281            *            @arg ADC_InjectedChannel_2: Injected Channel2 selected
   1282            *            @arg ADC_InjectedChannel_3: Injected Channel3 selected
   1283            *            @arg ADC_InjectedChannel_4: Injected Channel4 selected
   1284            * @param  Offset: the offset value for the selected ADC injected channel
   1285            *          This parameter must be a 12bit value.
   1286            * @retval None
   1287            */
   1288          void ADC_SetInjectedOffset(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel, uint16_t Offset)
   1289          {
   1290              __IO uint32_t tmp = 0;
   1291            /* Check the parameters */
   1292            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1293            assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
   1294            assert_param(IS_ADC_OFFSET(Offset));
   1295            
   1296            tmp = (uint32_t)ADCx;
   1297            tmp += ADC_InjectedChannel;
   1298            
   1299            /* Set the selected injected channel data offset */
   1300           *(__IO uint32_t *) tmp = (uint32_t)Offset;
   1301          }
   1302          
   1303           /**
   1304            * @brief  Configures the ADCx external trigger for injected channels conversion.
   1305            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1306            * @param  ADC_ExternalTrigInjecConv: specifies the ADC trigger to start injected conversion.
   1307            *          This parameter can be one of the following values:                    
   1308            *            @arg ADC_ExternalTrigInjecConv_T1_CC4: Timer1 capture compare4 selected 
   1309            *            @arg ADC_ExternalTrigInjecConv_T1_TRGO: Timer1 TRGO event selected 
   1310            *            @arg ADC_ExternalTrigInjecConv_T2_CC1: Timer2 capture compare1 selected 
   1311            *            @arg ADC_ExternalTrigInjecConv_T2_TRGO: Timer2 TRGO event selected 
   1312            *            @arg ADC_ExternalTrigInjecConv_T3_CC2: Timer3 capture compare2 selected 
   1313            *            @arg ADC_ExternalTrigInjecConv_T3_CC4: Timer3 capture compare4 selected 
   1314            *            @arg ADC_ExternalTrigInjecConv_T4_CC1: Timer4 capture compare1 selected                       
   1315            *            @arg ADC_ExternalTrigInjecConv_T4_CC2: Timer4 capture compare2 selected 
   1316            *            @arg ADC_ExternalTrigInjecConv_T4_CC3: Timer4 capture compare3 selected                        
   1317            *            @arg ADC_ExternalTrigInjecConv_T4_TRGO: Timer4 TRGO event selected 
   1318            *            @arg ADC_ExternalTrigInjecConv_T5_CC4: Timer5 capture compare4 selected                        
   1319            *            @arg ADC_ExternalTrigInjecConv_T5_TRGO: Timer5 TRGO event selected                        
   1320            *            @arg ADC_ExternalTrigInjecConv_T8_CC2: Timer8 capture compare2 selected
   1321            *            @arg ADC_ExternalTrigInjecConv_T8_CC3: Timer8 capture compare3 selected                        
   1322            *            @arg ADC_ExternalTrigInjecConv_T8_CC4: Timer8 capture compare4 selected 
   1323            *            @arg ADC_ExternalTrigInjecConv_Ext_IT15: External interrupt line 15 event selected                          
   1324            * @retval None
   1325            */
   1326          void ADC_ExternalTrigInjectedConvConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConv)
   1327          {
   1328            uint32_t tmpreg = 0;
   1329            /* Check the parameters */
   1330            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1331            assert_param(IS_ADC_EXT_INJEC_TRIG(ADC_ExternalTrigInjecConv));
   1332            
   1333            /* Get the old register value */
   1334            tmpreg = ADCx->CR2;
   1335            
   1336            /* Clear the old external event selection for injected group */
   1337            tmpreg &= CR2_JEXTSEL_RESET;
   1338            
   1339            /* Set the external event selection for injected group */
   1340            tmpreg |= ADC_ExternalTrigInjecConv;
   1341            
   1342            /* Store the new register value */
   1343            ADCx->CR2 = tmpreg;
   1344          }
   1345          
   1346          /**
   1347            * @brief  Configures the ADCx external trigger edge for injected channels conversion.
   1348            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1349            * @param  ADC_ExternalTrigInjecConvEdge: specifies the ADC external trigger edge
   1350            *         to start injected conversion. 
   1351            *          This parameter can be one of the following values:
   1352            *            @arg ADC_ExternalTrigInjecConvEdge_None: external trigger disabled for 
   1353            *                                                     injected conversion
   1354            *            @arg ADC_ExternalTrigInjecConvEdge_Rising: detection on rising edge
   1355            *            @arg ADC_ExternalTrigInjecConvEdge_Falling: detection on falling edge
   1356            *            @arg ADC_ExternalTrigInjecConvEdge_RisingFalling: detection on both rising 
   1357            *                                                               and falling edge
   1358            * @retval None
   1359            */
   1360          void ADC_ExternalTrigInjectedConvEdgeConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConvEdge)
   1361          {
   1362            uint32_t tmpreg = 0;
   1363            /* Check the parameters */
   1364            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1365            assert_param(IS_ADC_EXT_INJEC_TRIG_EDGE(ADC_ExternalTrigInjecConvEdge));
   1366            /* Get the old register value */
   1367            tmpreg = ADCx->CR2;
   1368            /* Clear the old external trigger edge for injected group */
   1369            tmpreg &= CR2_JEXTEN_RESET;
   1370            /* Set the new external trigger edge for injected group */
   1371            tmpreg |= ADC_ExternalTrigInjecConvEdge;
   1372            /* Store the new register value */
   1373            ADCx->CR2 = tmpreg;
   1374          }
   1375          
   1376          /**
   1377            * @brief  Enables the selected ADC software start conversion of the injected channels.
   1378            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1379            * @retval None
   1380            */
   1381          void ADC_SoftwareStartInjectedConv(ADC_TypeDef* ADCx)
   1382          {
   1383            /* Check the parameters */
   1384            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1385            /* Enable the selected ADC conversion for injected group */
   1386            ADCx->CR2 |= (uint32_t)ADC_CR2_JSWSTART;
   1387          }
   1388          
   1389          /**
   1390            * @brief  Gets the selected ADC Software start injected conversion Status.
   1391            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1392            * @retval The new state of ADC software start injected conversion (SET or RESET).
   1393            */
   1394          FlagStatus ADC_GetSoftwareStartInjectedConvCmdStatus(ADC_TypeDef* ADCx)
   1395          {
   1396            FlagStatus bitstatus = RESET;
   1397            /* Check the parameters */
   1398            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1399            
   1400            /* Check the status of JSWSTART bit */
   1401            if ((ADCx->CR2 & ADC_CR2_JSWSTART) != (uint32_t)RESET)
   1402            {
   1403              /* JSWSTART bit is set */
   1404              bitstatus = SET;
   1405            }
   1406            else
   1407            {
   1408              /* JSWSTART bit is reset */
   1409              bitstatus = RESET;
   1410            }
   1411            /* Return the JSWSTART bit status */
   1412            return  bitstatus;
   1413          }
   1414          
   1415          /**
   1416            * @brief  Enables or disables the selected ADC automatic injected group 
   1417            *         conversion after regular one.
   1418            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1419            * @param  NewState: new state of the selected ADC auto injected conversion
   1420            *          This parameter can be: ENABLE or DISABLE.
   1421            * @retval None
   1422            */
   1423          void ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
   1424          {
   1425            /* Check the parameters */
   1426            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1427            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1428            if (NewState != DISABLE)
   1429            {
   1430              /* Enable the selected ADC automatic injected group conversion */
   1431              ADCx->CR1 |= (uint32_t)ADC_CR1_JAUTO;
   1432            }
   1433            else
   1434            {
   1435              /* Disable the selected ADC automatic injected group conversion */
   1436              ADCx->CR1 &= (uint32_t)(~ADC_CR1_JAUTO);
   1437            }
   1438          }
   1439          
   1440          /**
   1441            * @brief  Enables or disables the discontinuous mode for injected group 
   1442            *         channel for the specified ADC
   1443            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1444            * @param  NewState: new state of the selected ADC discontinuous mode on injected
   1445            *         group channel.
   1446            *          This parameter can be: ENABLE or DISABLE.
   1447            * @retval None
   1448            */
   1449          void ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
   1450          {
   1451            /* Check the parameters */
   1452            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1453            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1454            if (NewState != DISABLE)
   1455            {
   1456              /* Enable the selected ADC injected discontinuous mode */
   1457              ADCx->CR1 |= (uint32_t)ADC_CR1_JDISCEN;
   1458            }
   1459            else
   1460            {
   1461              /* Disable the selected ADC injected discontinuous mode */
   1462              ADCx->CR1 &= (uint32_t)(~ADC_CR1_JDISCEN);
   1463            }
   1464          }
   1465          
   1466          /**
   1467            * @brief  Returns the ADC injected channel conversion result
   1468            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1469            * @param  ADC_InjectedChannel: the converted ADC injected channel.
   1470            *          This parameter can be one of the following values:
   1471            *            @arg ADC_InjectedChannel_1: Injected Channel1 selected
   1472            *            @arg ADC_InjectedChannel_2: Injected Channel2 selected
   1473            *            @arg ADC_InjectedChannel_3: Injected Channel3 selected
   1474            *            @arg ADC_InjectedChannel_4: Injected Channel4 selected
   1475            * @retval The Data conversion value.
   1476            */
   1477          uint16_t ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel)
   1478          {
   1479            __IO uint32_t tmp = 0;
   1480            
   1481            /* Check the parameters */
   1482            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1483            assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
   1484          
   1485            tmp = (uint32_t)ADCx;
   1486            tmp += ADC_InjectedChannel + JDR_OFFSET;
   1487            
   1488            /* Returns the selected injected channel conversion data value */
   1489            return (uint16_t) (*(__IO uint32_t*)  tmp); 
   1490          }
   1491          /**
   1492            * @}
   1493            */
   1494          
   1495          /** @defgroup ADC_Group7 Interrupts and flags management functions
   1496           *  @brief   Interrupts and flags management functions
   1497           *
   1498          @verbatim   
   1499           ===============================================================================
   1500                      ##### Interrupts and flags management functions #####
   1501           ===============================================================================  
   1502          
   1503              [..] This section provides functions allowing to configure the ADC Interrupts 
   1504                   and to get the status and clear flags and Interrupts pending bits.
   1505            
   1506              [..] Each ADC provides 4 Interrupts sources and 6 Flags which can be divided
   1507                  into 3 groups:
   1508            
   1509            *** Flags and Interrupts for ADC regular channels ***
   1510            =====================================================
   1511              [..]
   1512                (+) Flags :
   1513                  (##) ADC_FLAG_OVR : Overrun detection when regular converted data are lost
   1514          
   1515                  (##) ADC_FLAG_EOC : Regular channel end of conversion ==> to indicate 
   1516                       (depending on EOCS bit, managed by ADC_EOCOnEachRegularChannelCmd() )
   1517                       the end of:
   1518                       (+++) a regular CHANNEL conversion 
   1519                       (+++) sequence of regular GROUP conversions .
   1520          
   1521                  (##) ADC_FLAG_STRT: Regular channel start ==> to indicate when regular 
   1522                       CHANNEL conversion starts.
   1523              [..]
   1524                (+) Interrupts :
   1525                  (##) ADC_IT_OVR : specifies the interrupt source for Overrun detection 
   1526                       event.  
   1527                  (##) ADC_IT_EOC : specifies the interrupt source for Regular channel end
   1528                       of conversion event.
   1529            
   1530            
   1531            *** Flags and Interrupts for ADC Injected channels ***
   1532            ======================================================
   1533              [..]
   1534                (+) Flags :
   1535                  (##) ADC_FLAG_JEOC : Injected channel end of conversion ==> to indicate 
   1536                       at the end of injected GROUP conversion  
   1537                        
   1538                  (##) ADC_FLAG_JSTRT: Injected channel start ==> to indicate hardware when 
   1539                       injected GROUP conversion starts.
   1540              [..]
   1541                (+) Interrupts :
   1542                  (##) ADC_IT_JEOC : specifies the interrupt source for Injected channel 
   1543                       end of conversion event.     
   1544          
   1545            *** General Flags and Interrupts for the ADC ***
   1546            ================================================ 
   1547              [..]
   1548                (+)Flags :
   1549                  (##) ADC_FLAG_AWD: Analog watchdog ==> to indicate if the converted voltage 
   1550                       crosses the programmed thresholds values.
   1551              [..]          
   1552                (+) Interrupts :
   1553                  (##) ADC_IT_AWD : specifies the interrupt source for Analog watchdog event. 
   1554          
   1555            
   1556              [..] The user should identify which mode will be used in his application to 
   1557                   manage the ADC controller events: Polling mode or Interrupt mode.
   1558            
   1559              [..] In the Polling Mode it is advised to use the following functions:
   1560                (+) ADC_GetFlagStatus() : to check if flags events occur. 
   1561                (+) ADC_ClearFlag()     : to clear the flags events.
   1562                
   1563              [..] In the Interrupt Mode it is advised to use the following functions:
   1564                (+) ADC_ITConfig()          : to enable or disable the interrupt source.
   1565                (+) ADC_GetITStatus()       : to check if Interrupt occurs.
   1566                (+) ADC_ClearITPendingBit() : to clear the Interrupt pending Bit 
   1567                                             (corresponding Flag). 
   1568          @endverbatim
   1569            * @{
   1570            */ 
   1571          /**
   1572            * @brief  Enables or disables the specified ADC interrupts.
   1573            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1574            * @param  ADC_IT: specifies the ADC interrupt sources to be enabled or disabled. 
   1575            *          This parameter can be one of the following values:
   1576            *            @arg ADC_IT_EOC: End of conversion interrupt mask
   1577            *            @arg ADC_IT_AWD: Analog watchdog interrupt mask
   1578            *            @arg ADC_IT_JEOC: End of injected conversion interrupt mask
   1579            *            @arg ADC_IT_OVR: Overrun interrupt enable                       
   1580            * @param  NewState: new state of the specified ADC interrupts.
   1581            *          This parameter can be: ENABLE or DISABLE.
   1582            * @retval None
   1583            */
   1584          void ADC_ITConfig(ADC_TypeDef* ADCx, uint16_t ADC_IT, FunctionalState NewState)  
   1585          {
   1586            uint32_t itmask = 0;
   1587            /* Check the parameters */
   1588            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1589            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1590            assert_param(IS_ADC_IT(ADC_IT)); 
   1591          
   1592            /* Get the ADC IT index */
   1593            itmask = (uint8_t)ADC_IT;
   1594            itmask = (uint32_t)0x01 << itmask;    
   1595          
   1596            if (NewState != DISABLE)
   1597            {
   1598              /* Enable the selected ADC interrupts */
   1599              ADCx->CR1 |= itmask;
   1600            }
   1601            else
   1602            {
   1603              /* Disable the selected ADC interrupts */
   1604              ADCx->CR1 &= (~(uint32_t)itmask);
   1605            }
   1606          }
   1607          
   1608          /**
   1609            * @brief  Checks whether the specified ADC flag is set or not.
   1610            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1611            * @param  ADC_FLAG: specifies the flag to check. 
   1612            *          This parameter can be one of the following values:
   1613            *            @arg ADC_FLAG_AWD: Analog watchdog flag
   1614            *            @arg ADC_FLAG_EOC: End of conversion flag
   1615            *            @arg ADC_FLAG_JEOC: End of injected group conversion flag
   1616            *            @arg ADC_FLAG_JSTRT: Start of injected group conversion flag
   1617            *            @arg ADC_FLAG_STRT: Start of regular group conversion flag
   1618            *            @arg ADC_FLAG_OVR: Overrun flag                                                 
   1619            * @retval The new state of ADC_FLAG (SET or RESET).
   1620            */
   1621          FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, uint8_t ADC_FLAG)
   1622          {
   1623            FlagStatus bitstatus = RESET;
   1624            /* Check the parameters */
   1625            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1626            assert_param(IS_ADC_GET_FLAG(ADC_FLAG));
   1627          
   1628            /* Check the status of the specified ADC flag */
   1629            if ((ADCx->SR & ADC_FLAG) != (uint8_t)RESET)
   1630            {
   1631              /* ADC_FLAG is set */
   1632              bitstatus = SET;
   1633            }
   1634            else
   1635            {
   1636              /* ADC_FLAG is reset */
   1637              bitstatus = RESET;
   1638            }
   1639            /* Return the ADC_FLAG status */
   1640            return  bitstatus;
   1641          }
   1642          
   1643          /**
   1644            * @brief  Clears the ADCx's pending flags.
   1645            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1646            * @param  ADC_FLAG: specifies the flag to clear. 
   1647            *          This parameter can be any combination of the following values:
   1648            *            @arg ADC_FLAG_AWD: Analog watchdog flag
   1649            *            @arg ADC_FLAG_EOC: End of conversion flag
   1650            *            @arg ADC_FLAG_JEOC: End of injected group conversion flag
   1651            *            @arg ADC_FLAG_JSTRT: Start of injected group conversion flag
   1652            *            @arg ADC_FLAG_STRT: Start of regular group conversion flag
   1653            *            @arg ADC_FLAG_OVR: Overrun flag                          
   1654            * @retval None
   1655            */
   1656          void ADC_ClearFlag(ADC_TypeDef* ADCx, uint8_t ADC_FLAG)
   1657          {
   1658            /* Check the parameters */
   1659            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1660            assert_param(IS_ADC_CLEAR_FLAG(ADC_FLAG));
   1661          
   1662            /* Clear the selected ADC flags */
   1663            ADCx->SR = ~(uint32_t)ADC_FLAG;
   1664          }
   1665          
   1666          /**
   1667            * @brief  Checks whether the specified ADC interrupt has occurred or not.
   1668            * @param  ADCx:   where x can be 1, 2 or 3 to select the ADC peripheral.
   1669            * @param  ADC_IT: specifies the ADC interrupt source to check. 
   1670            *          This parameter can be one of the following values:
   1671            *            @arg ADC_IT_EOC: End of conversion interrupt mask
   1672            *            @arg ADC_IT_AWD: Analog watchdog interrupt mask
   1673            *            @arg ADC_IT_JEOC: End of injected conversion interrupt mask
   1674            *            @arg ADC_IT_OVR: Overrun interrupt mask                        
   1675            * @retval The new state of ADC_IT (SET or RESET).
   1676            */
   1677          ITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, uint16_t ADC_IT)
   1678          {
   1679            ITStatus bitstatus = RESET;
   1680            uint32_t itmask = 0, enablestatus = 0;
   1681          
   1682            /* Check the parameters */
   1683            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1684            assert_param(IS_ADC_IT(ADC_IT));
   1685          
   1686            /* Get the ADC IT index */
   1687            itmask = ADC_IT >> 8;
   1688          
   1689            /* Get the ADC_IT enable bit status */
   1690            enablestatus = (ADCx->CR1 & ((uint32_t)0x01 << (uint8_t)ADC_IT)) ;
   1691          
   1692            /* Check the status of the specified ADC interrupt */
   1693            if (((ADCx->SR & itmask) != (uint32_t)RESET) && enablestatus)
   1694            {
   1695              /* ADC_IT is set */
   1696              bitstatus = SET;
   1697            }
   1698            else
   1699            {
   1700              /* ADC_IT is reset */
   1701              bitstatus = RESET;
   1702            }
   1703            /* Return the ADC_IT status */
   1704            return  bitstatus;
   1705          }
   1706          
   1707          /**
   1708            * @brief  Clears the ADCx's interrupt pending bits.
   1709            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1710            * @param  ADC_IT: specifies the ADC interrupt pending bit to clear.
   1711            *          This parameter can be one of the following values:
   1712            *            @arg ADC_IT_EOC: End of conversion interrupt mask
   1713            *            @arg ADC_IT_AWD: Analog watchdog interrupt mask
   1714            *            @arg ADC_IT_JEOC: End of injected conversion interrupt mask
   1715            *            @arg ADC_IT_OVR: Overrun interrupt mask                         
   1716            * @retval None
   1717            */
   1718          void ADC_ClearITPendingBit(ADC_TypeDef* ADCx, uint16_t ADC_IT)
   1719          {
   1720            uint8_t itmask = 0;
   1721            /* Check the parameters */
   1722            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1723            assert_param(IS_ADC_IT(ADC_IT)); 
   1724            /* Get the ADC IT index */
   1725            itmask = (uint8_t)(ADC_IT >> 8);
   1726            /* Clear the selected ADC interrupt pending bits */
   1727            ADCx->SR = ~(uint32_t)itmask;
   1728          }                    
   1729          /**
   1730            * @}
   1731            */ 
   1732          
   1733          /**
   1734            * @}
   1735            */
   1736          
   1737          /**
   1738            * @}
   1739            */ 
   1740          
   1741          /**
   1742            * @}
   1743            */ 
   1744          
   1745          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   ADC_AnalogWatchdogCmd
       0   ADC_AnalogWatchdogSingleChannelConfig
       0   ADC_AnalogWatchdogThresholdsConfig
       0   ADC_AutoInjectedConvCmd
       0   ADC_ClearFlag
       0   ADC_ClearITPendingBit
       0   ADC_Cmd
       0   ADC_CommonInit
       0   ADC_CommonStructInit
       0   ADC_ContinuousModeCmd
       0   ADC_DMACmd
       0   ADC_DMARequestAfterLastTransferCmd
       8   ADC_DeInit
         0   -> RCC_APB2PeriphResetCmd
         8   -> RCC_APB2PeriphResetCmd
       0   ADC_DiscModeChannelCountConfig
       0   ADC_DiscModeCmd
       0   ADC_EOCOnEachRegularChannelCmd
       0   ADC_ExternalTrigInjectedConvConfig
       0   ADC_ExternalTrigInjectedConvEdgeConfig
       0   ADC_GetConversionValue
       0   ADC_GetFlagStatus
       8   ADC_GetITStatus
       4   ADC_GetInjectedConversionValue
       0   ADC_GetMultiModeConversionValue
       0   ADC_GetSoftwareStartConvStatus
       0   ADC_GetSoftwareStartInjectedConvCmdStatus
       0   ADC_ITConfig
       0   ADC_Init
      16   ADC_InjectedChannelConfig
       0   ADC_InjectedDiscModeCmd
       0   ADC_InjectedSequencerLengthConfig
       0   ADC_MultiModeDMARequestAfterLastTransferCmd
      16   ADC_RegularChannelConfig
       4   ADC_SetInjectedOffset
       0   ADC_SoftwareStartConv
       0   ADC_SoftwareStartInjectedConv
       0   ADC_StructInit
       0   ADC_TempSensorVrefintCmd
       0   ADC_VBATCmd


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       6  ?Subroutine0
       6  ?Subroutine1
       6  ?Subroutine2
      12  ADC_AnalogWatchdogCmd
      12  ADC_AnalogWatchdogSingleChannelConfig
       6  ADC_AnalogWatchdogThresholdsConfig
      18  ADC_AutoInjectedConvCmd
       2  ADC_ClearFlag
       2  ADC_ClearITPendingBit
      18  ADC_Cmd
      28  ADC_CommonInit
      12  ADC_CommonStructInit
      18  ADC_ContinuousModeCmd
      18  ADC_DMACmd
      18  ADC_DMARequestAfterLastTransferCmd
      26  ADC_DeInit
      16  ADC_DiscModeChannelCountConfig
      18  ADC_DiscModeCmd
      18  ADC_EOCOnEachRegularChannelCmd
       8  ADC_ExternalTrigInjectedConvConfig
       6  ADC_ExternalTrigInjectedConvEdgeConfig
       6  ADC_GetConversionValue
      14  ADC_GetFlagStatus
      28  ADC_GetITStatus
      26  ADC_GetInjectedConversionValue
       6  ADC_GetMultiModeConversionValue
       6  ADC_GetSoftwareStartConvStatus
       4  ADC_GetSoftwareStartInjectedConvCmdStatus
      22  ADC_ITConfig
      64  ADC_Init
      80  ADC_InjectedChannelConfig
      18  ADC_InjectedDiscModeCmd
      16  ADC_InjectedSequencerLengthConfig
      20  ADC_MultiModeDMARequestAfterLastTransferCmd
     120  ADC_RegularChannelConfig
      24  ADC_SetInjectedOffset
      10  ADC_SoftwareStartConv
      10  ADC_SoftwareStartInjectedConv
      20  ADC_StructInit
      20  ADC_TempSensorVrefintCmd
      20  ADC_VBATCmd

 
 832 bytes in section .text
 
 832 bytes of CODE memory

Errors: none
Warnings: none
