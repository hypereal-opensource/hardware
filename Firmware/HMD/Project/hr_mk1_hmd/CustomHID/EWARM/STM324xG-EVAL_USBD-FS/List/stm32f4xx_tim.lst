###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.2.7424/W32 for ARM        11/Oct/2016  09:24:40
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\yfjiang\Desktop\Repo\HR-MK1\Firmware\HMD\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_tim.c
#    Command line =  
#        C:\Users\yfjiang\Desktop\Repo\HR-MK1\Firmware\HMD\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_tim.c
#        -D USE_STDPERIPH_DRIVER -D STM32F40_41xxx -D USE_STM324xG_EVAL -D
#        USE_USB_OTG_FS -lcN
#        C:\Users\yfjiang\Desktop\Repo\HR-MK1\Firmware\HMD\Project\hr_mk1_hmd\CustomHID\EWARM\STM324xG-EVAL_USBD-FS\List\
#        -o
#        C:\Users\yfjiang\Desktop\Repo\HR-MK1\Firmware\HMD\Project\hr_mk1_hmd\CustomHID\EWARM\STM324xG-EVAL_USBD-FS\Obj\
#        --debug --endian=little --cpu=Cortex-M4F -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        C:\Users\yfjiang\Desktop\Repo\HR-MK1\Firmware\HMD\Project\hr_mk1_hmd\CustomHID\EWARM\..\
#        -I
#        C:\Users\yfjiang\Desktop\Repo\HR-MK1\Firmware\HMD\Project\hr_mk1_hmd\CustomHID\EWARM\..\inc\
#        -I
#        C:\Users\yfjiang\Desktop\Repo\HR-MK1\Firmware\HMD\Project\hr_mk1_hmd\CustomHID\EWARM\..\..\..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include\
#        -I
#        C:\Users\yfjiang\Desktop\Repo\HR-MK1\Firmware\HMD\Project\hr_mk1_hmd\CustomHID\EWARM\..\..\..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\
#        -I
#        C:\Users\yfjiang\Desktop\Repo\HR-MK1\Firmware\HMD\Project\hr_mk1_hmd\CustomHID\EWARM\..\..\..\..\Libraries\STM32_USB_OTG_Driver\inc\
#        -I
#        C:\Users\yfjiang\Desktop\Repo\HR-MK1\Firmware\HMD\Project\hr_mk1_hmd\CustomHID\EWARM\..\..\..\..\Libraries\STM32_USB_Device_Library\Core\inc\
#        -I
#        C:\Users\yfjiang\Desktop\Repo\HR-MK1\Firmware\HMD\Project\hr_mk1_hmd\CustomHID\EWARM\..\..\..\..\Libraries\STM32_USB_Device_Library\Class\customhid\inc\
#        -I
#        C:\Users\yfjiang\Desktop\Repo\HR-MK1\Firmware\HMD\Project\hr_mk1_hmd\CustomHID\EWARM\..\..\..\..\Utilities\STM32_EVAL\
#        -I
#        C:\Users\yfjiang\Desktop\Repo\HR-MK1\Firmware\HMD\Project\hr_mk1_hmd\CustomHID\EWARM\..\..\..\..\Utilities\STM32_EVAL\Common\
#        -I
#        C:\Users\yfjiang\Desktop\Repo\HR-MK1\Firmware\HMD\Project\hr_mk1_hmd\CustomHID\EWARM\..\..\..\..\Utilities\STM32_EVAL\STM3240_41_G_EVAL\
#        -Ohz --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        C:\Users\yfjiang\Desktop\Repo\HR-MK1\Firmware\HMD\Project\hr_mk1_hmd\CustomHID\EWARM\STM324xG-EVAL_USBD-FS\List\stm32f4xx_tim.lst
#    Object file  =  
#        C:\Users\yfjiang\Desktop\Repo\HR-MK1\Firmware\HMD\Project\hr_mk1_hmd\CustomHID\EWARM\STM324xG-EVAL_USBD-FS\Obj\stm32f4xx_tim.o
#
###############################################################################

C:\Users\yfjiang\Desktop\Repo\HR-MK1\Firmware\HMD\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_tim.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_tim.c
      4            * @author  MCD Application Team
      5            * @version V1.6.0
      6            * @date    10-July-2015
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the TIM peripheral:
      9            *            + TimeBase management
     10            *            + Output Compare management
     11            *            + Input Capture management
     12            *            + Advanced-control timers (TIM1 and TIM8) specific features  
     13            *            + Interrupts, DMA and flags management
     14            *            + Clocks management
     15            *            + Synchronization management
     16            *            + Specific interface management
     17            *            + Specific remapping management      
     18            *              
     19            @verbatim   
     20           ===============================================================================
     21                             #####  How to use this driver #####
     22           ===============================================================================
     23              [..]
     24              This driver provides functions to configure and program the TIM 
     25              of all STM32F4xx devices.
     26              These functions are split in 9 groups: 
     27               
     28                (#) TIM TimeBase management: this group includes all needed functions 
     29                    to configure the TM Timebase unit:
     30                  (++) Set/Get Prescaler
     31                  (++) Set/Get Autoreload  
     32                  (++) Counter modes configuration
     33                  (++) Set Clock division  
     34                  (++) Select the One Pulse mode
     35                  (++) Update Request Configuration
     36                  (++) Update Disable Configuration
     37                  (++) Auto-Preload Configuration 
     38                  (++) Enable/Disable the counter     
     39                             
     40                (#) TIM Output Compare management: this group includes all needed 
     41                    functions to configure the Capture/Compare unit used in Output 
     42                    compare mode: 
     43                  (++) Configure each channel, independently, in Output Compare mode
     44                  (++) Select the output compare modes
     45                  (++) Select the Polarities of each channel
     46                  (++) Set/Get the Capture/Compare register values
     47                  (++) Select the Output Compare Fast mode 
     48                  (++) Select the Output Compare Forced mode  
     49                  (++) Output Compare-Preload Configuration 
     50                  (++) Clear Output Compare Reference
     51                  (++) Select the OCREF Clear signal
     52                  (++) Enable/Disable the Capture/Compare Channels    
     53                               
     54                (#) TIM Input Capture management: this group includes all needed 
     55                    functions to configure the Capture/Compare unit used in 
     56                    Input Capture mode:
     57                  (++) Configure each channel in input capture mode
     58                  (++) Configure Channel1/2 in PWM Input mode
     59                  (++) Set the Input Capture Prescaler
     60                  (++) Get the Capture/Compare values      
     61                               
     62                (#) Advanced-control timers (TIM1 and TIM8) specific features
     63                  (++) Configures the Break input, dead time, Lock level, the OSSI,
     64                       the OSSR State and the AOE(automatic output enable)
     65                  (++) Enable/Disable the TIM peripheral Main Outputs
     66                  (++) Select the Commutation event
     67                  (++) Set/Reset the Capture Compare Preload Control bit
     68                                          
     69                (#) TIM interrupts, DMA and flags management
     70                  (++) Enable/Disable interrupt sources
     71                  (++) Get flags status
     72                  (++) Clear flags/ Pending bits
     73                  (++) Enable/Disable DMA requests 
     74                  (++) Configure DMA burst mode
     75                  (++) Select CaptureCompare DMA request  
     76                          
     77                (#) TIM clocks management: this group includes all needed functions 
     78                    to configure the clock controller unit:
     79                  (++) Select internal/External clock
     80                  (++) Select the external clock mode: ETR(Mode1/Mode2), TIx or ITRx
     81                     
     82                (#) TIM synchronization management: this group includes all needed 
     83                    functions to configure the Synchronization unit:
     84                  (++) Select Input Trigger  
     85                  (++) Select Output Trigger  
     86                  (++) Select Master Slave Mode 
     87                  (++) ETR Configuration when used as external trigger   
     88                 
     89                (#) TIM specific interface management, this group includes all 
     90                    needed functions to use the specific TIM interface:
     91                  (++) Encoder Interface Configuration
     92                  (++) Select Hall Sensor   
     93                     
     94                (#) TIM specific remapping management includes the Remapping 
     95                    configuration of specific timers               
     96               
     97            @endverbatim    
     98            ******************************************************************************
     99            * @attention
    100            *
    101            * <h2><center>&copy; COPYRIGHT 2015 STMicroelectronics</center></h2>
    102            *
    103            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
    104            * You may not use this file except in compliance with the License.
    105            * You may obtain a copy of the License at:
    106            *
    107            *        http://www.st.com/software_license_agreement_liberty_v2
    108            *
    109            * Unless required by applicable law or agreed to in writing, software 
    110            * distributed under the License is distributed on an "AS IS" BASIS, 
    111            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    112            * See the License for the specific language governing permissions and
    113            * limitations under the License.
    114            *
    115            ******************************************************************************
    116            */
    117          
    118          /* Includes ------------------------------------------------------------------*/
    119          #include "stm32f4xx_tim.h"
    120          #include "stm32f4xx_rcc.h"
    121          
    122          /** @addtogroup STM32F4xx_StdPeriph_Driver
    123            * @{
    124            */
    125          
    126          /** @defgroup TIM 
    127            * @brief TIM driver modules
    128            * @{
    129            */
    130          
    131          /* Private typedef -----------------------------------------------------------*/
    132          /* Private define ------------------------------------------------------------*/
    133          
    134          /* ---------------------- TIM registers bit mask ------------------------ */
    135          #define SMCR_ETR_MASK      ((uint16_t)0x00FF) 
    136          #define CCMR_OFFSET        ((uint16_t)0x0018)
    137          #define CCER_CCE_SET       ((uint16_t)0x0001)  
    138          #define	CCER_CCNE_SET      ((uint16_t)0x0004) 
    139          #define CCMR_OC13M_MASK    ((uint16_t)0xFF8F)
    140          #define CCMR_OC24M_MASK    ((uint16_t)0x8FFF) 
    141          
    142          /* Private macro -------------------------------------------------------------*/
    143          /* Private variables ---------------------------------------------------------*/
    144          /* Private function prototypes -----------------------------------------------*/
    145          static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
    146                                 uint16_t TIM_ICFilter);
    147          static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
    148                                 uint16_t TIM_ICFilter);
    149          static void TI3_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
    150                                 uint16_t TIM_ICFilter);
    151          static void TI4_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
    152                                 uint16_t TIM_ICFilter);
    153          
    154          /* Private functions ---------------------------------------------------------*/
    155          
    156          /** @defgroup TIM_Private_Functions
    157            * @{
    158            */
    159          
    160          /** @defgroup TIM_Group1 TimeBase management functions
    161           *  @brief   TimeBase management functions 
    162           *
    163          @verbatim   
    164           ===============================================================================
    165                               ##### TimeBase management functions #####
    166           ===============================================================================  
    167            
    168               
    169                      ##### TIM Driver: how to use it in Timing(Time base) Mode #####
    170           ===============================================================================
    171              [..] 
    172              To use the Timer in Timing(Time base) mode, the following steps are mandatory:
    173                 
    174                (#) Enable TIM clock using RCC_APBxPeriphClockCmd(RCC_APBxPeriph_TIMx, ENABLE) function
    175                              
    176                (#) Fill the TIM_TimeBaseInitStruct with the desired parameters.
    177                 
    178                (#) Call TIM_TimeBaseInit(TIMx, &TIM_TimeBaseInitStruct) to configure the Time Base unit
    179                    with the corresponding configuration
    180                    
    181                (#) Enable the NVIC if you need to generate the update interrupt. 
    182                    
    183                (#) Enable the corresponding interrupt using the function TIM_ITConfig(TIMx, TIM_IT_Update) 
    184                 
    185                (#) Call the TIM_Cmd(ENABLE) function to enable the TIM counter.
    186                       
    187                 -@- All other functions can be used separately to modify, if needed,
    188                     a specific feature of the Timer. 
    189          
    190          @endverbatim
    191            * @{
    192            */
    193            
    194          /**
    195            * @brief  Deinitializes the TIMx peripheral registers to their default reset values.
    196            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
    197            * @retval None
    198          
    199            */
    200          void TIM_DeInit(TIM_TypeDef* TIMx)
    201          {
    202            /* Check the parameters */
    203            assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
    204           
    205            if (TIMx == TIM1)
    206            {
    207              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
    208              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
    209            } 
    210            else if (TIMx == TIM2) 
    211            {     
    212              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
    213              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
    214            }  
    215            else if (TIMx == TIM3)
    216            { 
    217              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
    218              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
    219            }  
    220            else if (TIMx == TIM4)
    221            { 
    222              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
    223              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
    224            }  
    225            else if (TIMx == TIM5)
    226            {      
    227              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, ENABLE);
    228              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, DISABLE);
    229            }  
    230            else if (TIMx == TIM6)  
    231            {    
    232              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
    233              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
    234            }  
    235            else if (TIMx == TIM7)
    236            {      
    237              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
    238              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
    239            }  
    240            else if (TIMx == TIM8)
    241            {      
    242              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);
    243              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);  
    244            }  
    245            else if (TIMx == TIM9)
    246            {      
    247              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, ENABLE);
    248              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, DISABLE);  
    249             }  
    250            else if (TIMx == TIM10)
    251            {      
    252              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, ENABLE);
    253              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, DISABLE);  
    254            }  
    255            else if (TIMx == TIM11) 
    256            {     
    257              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, ENABLE);
    258              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, DISABLE);  
    259            }  
    260            else if (TIMx == TIM12)
    261            {      
    262              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, ENABLE);
    263              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, DISABLE);  
    264            }  
    265            else if (TIMx == TIM13) 
    266            {       
    267              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, ENABLE);
    268              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, DISABLE);  
    269            }  
    270            else
    271            { 
    272              if (TIMx == TIM14) 
    273              {     
    274                RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, ENABLE);
    275                RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, DISABLE); 
    276              }   
    277            }
    278          }
    279          
    280          /**
    281            * @brief  Initializes the TIMx Time Base Unit peripheral according to 
    282            *         the specified parameters in the TIM_TimeBaseInitStruct.
    283            * @param  TIMx: where x can be  1 to 14 to select the TIM peripheral.
    284            * @param  TIM_TimeBaseInitStruct: pointer to a TIM_TimeBaseInitTypeDef structure
    285            *         that contains the configuration information for the specified TIM peripheral.
    286            * @retval None
    287            */
    288          void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
    289          {
    290            uint16_t tmpcr1 = 0;
    291          
    292            /* Check the parameters */
    293            assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
    294            assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
    295            assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));
    296          
    297            tmpcr1 = TIMx->CR1;  
    298          
    299            if((TIMx == TIM1) || (TIMx == TIM8)||
    300               (TIMx == TIM2) || (TIMx == TIM3)||
    301               (TIMx == TIM4) || (TIMx == TIM5)) 
    302            {
    303              /* Select the Counter Mode */
    304              tmpcr1 &= (uint16_t)(~(TIM_CR1_DIR | TIM_CR1_CMS));
    305              tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
    306            }
    307           
    308            if((TIMx != TIM6) && (TIMx != TIM7))
    309            {
    310              /* Set the clock division */
    311              tmpcr1 &=  (uint16_t)(~TIM_CR1_CKD);
    312              tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
    313            }
    314          
    315            TIMx->CR1 = tmpcr1;
    316          
    317            /* Set the Autoreload value */
    318            TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
    319           
    320            /* Set the Prescaler value */
    321            TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
    322              
    323            if ((TIMx == TIM1) || (TIMx == TIM8))  
    324            {
    325              /* Set the Repetition Counter value */
    326              TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
    327            }
    328          
    329            /* Generate an update event to reload the Prescaler 
    330               and the repetition counter(only for TIM1 and TIM8) value immediately */
    331            TIMx->EGR = TIM_PSCReloadMode_Immediate;          
    332          }
    333          
    334          /**
    335            * @brief  Fills each TIM_TimeBaseInitStruct member with its default value.
    336            * @param  TIM_TimeBaseInitStruct : pointer to a TIM_TimeBaseInitTypeDef
    337            *         structure which will be initialized.
    338            * @retval None
    339            */
    340          void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
    341          {
    342            /* Set the default configuration */
    343            TIM_TimeBaseInitStruct->TIM_Period = 0xFFFFFFFF;
    344            TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
    345            TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
    346            TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
    347            TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;
    348          }
    349          
    350          /**
    351            * @brief  Configures the TIMx Prescaler.
    352            * @param  TIMx: where x can be  1 to 14 to select the TIM peripheral.
    353            * @param  Prescaler: specifies the Prescaler Register value
    354            * @param  TIM_PSCReloadMode: specifies the TIM Prescaler Reload mode
    355            *          This parameter can be one of the following values:
    356            *            @arg TIM_PSCReloadMode_Update: The Prescaler is loaded at the update event.
    357            *            @arg TIM_PSCReloadMode_Immediate: The Prescaler is loaded immediately.
    358            * @retval None
    359            */
    360          void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode)
    361          {
    362            /* Check the parameters */
    363            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    364            assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
    365            /* Set the Prescaler value */
    366            TIMx->PSC = Prescaler;
    367            /* Set or reset the UG Bit */
    368            TIMx->EGR = TIM_PSCReloadMode;
    369          }
    370          
    371          /**
    372            * @brief  Specifies the TIMx Counter Mode to be used.
    373            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
    374            * @param  TIM_CounterMode: specifies the Counter Mode to be used
    375            *          This parameter can be one of the following values:
    376            *            @arg TIM_CounterMode_Up: TIM Up Counting Mode
    377            *            @arg TIM_CounterMode_Down: TIM Down Counting Mode
    378            *            @arg TIM_CounterMode_CenterAligned1: TIM Center Aligned Mode1
    379            *            @arg TIM_CounterMode_CenterAligned2: TIM Center Aligned Mode2
    380            *            @arg TIM_CounterMode_CenterAligned3: TIM Center Aligned Mode3
    381            * @retval None
    382            */
    383          void TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode)
    384          {
    385            uint16_t tmpcr1 = 0;
    386          
    387            /* Check the parameters */
    388            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
    389            assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));
    390          
    391            tmpcr1 = TIMx->CR1;
    392          
    393            /* Reset the CMS and DIR Bits */
    394            tmpcr1 &= (uint16_t)~(TIM_CR1_DIR | TIM_CR1_CMS);
    395          
    396            /* Set the Counter Mode */
    397            tmpcr1 |= TIM_CounterMode;
    398          
    399            /* Write to TIMx CR1 register */
    400            TIMx->CR1 = tmpcr1;
    401          }
    402          
    403          /**
    404            * @brief  Sets the TIMx Counter Register value
    405            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
    406            * @param  Counter: specifies the Counter register new value.
    407            * @retval None
    408            */
    409          void TIM_SetCounter(TIM_TypeDef* TIMx, uint32_t Counter)
    410          {
    411            /* Check the parameters */
    412             assert_param(IS_TIM_ALL_PERIPH(TIMx));
    413          
    414            /* Set the Counter Register value */
    415            TIMx->CNT = Counter;
    416          }
    417          
    418          /**
    419            * @brief  Sets the TIMx Autoreload Register value
    420            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
    421            * @param  Autoreload: specifies the Autoreload register new value.
    422            * @retval None
    423            */
    424          void TIM_SetAutoreload(TIM_TypeDef* TIMx, uint32_t Autoreload)
    425          {
    426            /* Check the parameters */
    427            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    428            
    429            /* Set the Autoreload Register value */
    430            TIMx->ARR = Autoreload;
    431          }
    432          
    433          /**
    434            * @brief  Gets the TIMx Counter value.
    435            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
    436            * @retval Counter Register value
    437            */
    438          uint32_t TIM_GetCounter(TIM_TypeDef* TIMx)
    439          {
    440            /* Check the parameters */
    441            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    442          
    443            /* Get the Counter Register value */
    444            return TIMx->CNT;
    445          }
    446          
    447          /**
    448            * @brief  Gets the TIMx Prescaler value.
    449            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
    450            * @retval Prescaler Register value.
    451            */
    452          uint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx)
    453          {
    454            /* Check the parameters */
    455            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    456          
    457            /* Get the Prescaler Register value */
    458            return TIMx->PSC;
    459          }
    460          
    461          /**
    462            * @brief  Enables or Disables the TIMx Update event.
    463            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
    464            * @param  NewState: new state of the TIMx UDIS bit
    465            *          This parameter can be: ENABLE or DISABLE.
    466            * @retval None
    467            */
    468          void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
    469          {
    470            /* Check the parameters */
    471            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    472            assert_param(IS_FUNCTIONAL_STATE(NewState));
    473          
    474            if (NewState != DISABLE)
    475            {
    476              /* Set the Update Disable Bit */
    477              TIMx->CR1 |= TIM_CR1_UDIS;
    478            }
    479            else
    480            {
    481              /* Reset the Update Disable Bit */
    482              TIMx->CR1 &= (uint16_t)~TIM_CR1_UDIS;
    483            }
    484          }
    485          
    486          /**
    487            * @brief  Configures the TIMx Update Request Interrupt source.
    488            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
    489            * @param  TIM_UpdateSource: specifies the Update source.
    490            *          This parameter can be one of the following values:
    491            *            @arg TIM_UpdateSource_Global: Source of update is the counter
    492            *                 overflow/underflow or the setting of UG bit, or an update
    493            *                 generation through the slave mode controller.
    494            *            @arg TIM_UpdateSource_Regular: Source of update is counter overflow/underflow.
    495            * @retval None
    496            */
    497          void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, uint16_t TIM_UpdateSource)
    498          {
    499            /* Check the parameters */
    500            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    501            assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));
    502          
    503            if (TIM_UpdateSource != TIM_UpdateSource_Global)
    504            {
    505              /* Set the URS Bit */
    506              TIMx->CR1 |= TIM_CR1_URS;
    507            }
    508            else
    509            {
    510              /* Reset the URS Bit */
    511              TIMx->CR1 &= (uint16_t)~TIM_CR1_URS;
    512            }
    513          }
    514          
    515          /**
    516            * @brief  Enables or disables TIMx peripheral Preload register on ARR.
    517            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
    518            * @param  NewState: new state of the TIMx peripheral Preload register
    519            *          This parameter can be: ENABLE or DISABLE.
    520            * @retval None
    521            */
    522          void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
    523          {
    524            /* Check the parameters */
    525            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    526            assert_param(IS_FUNCTIONAL_STATE(NewState));
    527          
    528            if (NewState != DISABLE)
    529            {
    530              /* Set the ARR Preload Bit */
    531              TIMx->CR1 |= TIM_CR1_ARPE;
    532            }
    533            else
    534            {
    535              /* Reset the ARR Preload Bit */
    536              TIMx->CR1 &= (uint16_t)~TIM_CR1_ARPE;
    537            }
    538          }
    539          
    540          /**
    541            * @brief  Selects the TIMx's One Pulse Mode.
    542            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
    543            * @param  TIM_OPMode: specifies the OPM Mode to be used.
    544            *          This parameter can be one of the following values:
    545            *            @arg TIM_OPMode_Single
    546            *            @arg TIM_OPMode_Repetitive
    547            * @retval None
    548            */
    549          void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, uint16_t TIM_OPMode)
    550          {
    551            /* Check the parameters */
    552            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    553            assert_param(IS_TIM_OPM_MODE(TIM_OPMode));
    554          
    555            /* Reset the OPM Bit */
    556            TIMx->CR1 &= (uint16_t)~TIM_CR1_OPM;
    557          
    558            /* Configure the OPM Mode */
    559            TIMx->CR1 |= TIM_OPMode;
    560          }
    561          
    562          /**
    563            * @brief  Sets the TIMx Clock Division value.
    564            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
    565            * @param  TIM_CKD: specifies the clock division value.
    566            *          This parameter can be one of the following value:
    567            *            @arg TIM_CKD_DIV1: TDTS = Tck_tim
    568            *            @arg TIM_CKD_DIV2: TDTS = 2*Tck_tim
    569            *            @arg TIM_CKD_DIV4: TDTS = 4*Tck_tim
    570            * @retval None
    571            */
    572          void TIM_SetClockDivision(TIM_TypeDef* TIMx, uint16_t TIM_CKD)
    573          {
    574            /* Check the parameters */
    575            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
    576            assert_param(IS_TIM_CKD_DIV(TIM_CKD));
    577          
    578            /* Reset the CKD Bits */
    579            TIMx->CR1 &= (uint16_t)(~TIM_CR1_CKD);
    580          
    581            /* Set the CKD value */
    582            TIMx->CR1 |= TIM_CKD;
    583          }
    584          
    585          /**
    586            * @brief  Enables or disables the specified TIM peripheral.
    587            * @param  TIMx: where x can be 1 to 14 to select the TIMx peripheral.
    588            * @param  NewState: new state of the TIMx peripheral.
    589            *          This parameter can be: ENABLE or DISABLE.
    590            * @retval None
    591            */
    592          void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
    593          {
    594            /* Check the parameters */
    595            assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
    596            assert_param(IS_FUNCTIONAL_STATE(NewState));
    597            
    598            if (NewState != DISABLE)
    599            {
    600              /* Enable the TIM Counter */
    601              TIMx->CR1 |= TIM_CR1_CEN;
    602            }
    603            else
    604            {
    605              /* Disable the TIM Counter */
    606              TIMx->CR1 &= (uint16_t)~TIM_CR1_CEN;
    607            }
    608          }
    609          /**
    610            * @}
    611            */
    612          
    613          /** @defgroup TIM_Group2 Output Compare management functions
    614           *  @brief    Output Compare management functions 
    615           *
    616          @verbatim   
    617           ===============================================================================
    618                        ##### Output Compare management functions #####
    619           ===============================================================================  
    620             
    621                
    622                  ##### TIM Driver: how to use it in Output Compare Mode #####
    623           ===============================================================================
    624              [..] 
    625              To use the Timer in Output Compare mode, the following steps are mandatory:
    626                 
    627                (#) Enable TIM clock using RCC_APBxPeriphClockCmd(RCC_APBxPeriph_TIMx, ENABLE) 
    628                    function
    629                 
    630                (#) Configure the TIM pins by configuring the corresponding GPIO pins
    631                 
    632                (#) Configure the Time base unit as described in the first part of this driver, 
    633                  (++) if needed, else the Timer will run with the default configuration:
    634                      Autoreload value = 0xFFFF
    635                  (++) Prescaler value = 0x0000
    636                  (++) Counter mode = Up counting
    637                  (++) Clock Division = TIM_CKD_DIV1
    638                    
    639                (#) Fill the TIM_OCInitStruct with the desired parameters including:
    640                  (++) The TIM Output Compare mode: TIM_OCMode
    641                  (++) TIM Output State: TIM_OutputState
    642                  (++) TIM Pulse value: TIM_Pulse
    643                  (++) TIM Output Compare Polarity : TIM_OCPolarity
    644                 
    645                (#) Call TIM_OCxInit(TIMx, &TIM_OCInitStruct) to configure the desired 
    646                    channel with the corresponding configuration
    647                 
    648                (#) Call the TIM_Cmd(ENABLE) function to enable the TIM counter.
    649                 
    650                -@- All other functions can be used separately to modify, if needed,
    651                    a specific feature of the Timer. 
    652                    
    653                -@- In case of PWM mode, this function is mandatory:
    654                    TIM_OCxPreloadConfig(TIMx, TIM_OCPreload_ENABLE); 
    655                        
    656                -@- If the corresponding interrupt or DMA request are needed, the user should:
    657                  (+@) Enable the NVIC (or the DMA) to use the TIM interrupts (or DMA requests). 
    658                  (+@) Enable the corresponding interrupt (or DMA request) using the function 
    659                       TIM_ITConfig(TIMx, TIM_IT_CCx) (or TIM_DMA_Cmd(TIMx, TIM_DMA_CCx))   
    660          
    661          @endverbatim
    662            * @{
    663            */
    664          
    665          /**
    666            * @brief  Initializes the TIMx Channel1 according to the specified parameters in
    667            *         the TIM_OCInitStruct.
    668            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
    669            * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
    670            *         the configuration information for the specified TIM peripheral.
    671            * @retval None
    672            */
    673          void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
    674          {
    675            uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
    676             
    677            /* Check the parameters */
    678            assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
    679            assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
    680            assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
    681            assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
    682          
    683            /* Disable the Channel 1: Reset the CC1E Bit */
    684            TIMx->CCER &= (uint16_t)~TIM_CCER_CC1E;
    685            
    686            /* Get the TIMx CCER register value */
    687            tmpccer = TIMx->CCER;
    688            /* Get the TIMx CR2 register value */
    689            tmpcr2 =  TIMx->CR2;
    690            
    691            /* Get the TIMx CCMR1 register value */
    692            tmpccmrx = TIMx->CCMR1;
    693              
    694            /* Reset the Output Compare Mode Bits */
    695            tmpccmrx &= (uint16_t)~TIM_CCMR1_OC1M;
    696            tmpccmrx &= (uint16_t)~TIM_CCMR1_CC1S;
    697            /* Select the Output Compare Mode */
    698            tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
    699            
    700            /* Reset the Output Polarity level */
    701            tmpccer &= (uint16_t)~TIM_CCER_CC1P;
    702            /* Set the Output Compare Polarity */
    703            tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
    704            
    705            /* Set the Output State */
    706            tmpccer |= TIM_OCInitStruct->TIM_OutputState;
    707              
    708            if((TIMx == TIM1) || (TIMx == TIM8))
    709            {
    710              assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
    711              assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    712              assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    713              assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    714              
    715              /* Reset the Output N Polarity level */
    716              tmpccer &= (uint16_t)~TIM_CCER_CC1NP;
    717              /* Set the Output N Polarity */
    718              tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
    719              /* Reset the Output N State */
    720              tmpccer &= (uint16_t)~TIM_CCER_CC1NE;
    721              
    722              /* Set the Output N State */
    723              tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
    724              /* Reset the Output Compare and Output Compare N IDLE State */
    725              tmpcr2 &= (uint16_t)~TIM_CR2_OIS1;
    726              tmpcr2 &= (uint16_t)~TIM_CR2_OIS1N;
    727              /* Set the Output Idle state */
    728              tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
    729              /* Set the Output N Idle state */
    730              tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
    731            }
    732            /* Write to TIMx CR2 */
    733            TIMx->CR2 = tmpcr2;
    734            
    735            /* Write to TIMx CCMR1 */
    736            TIMx->CCMR1 = tmpccmrx;
    737            
    738            /* Set the Capture Compare Register value */
    739            TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse;
    740            
    741            /* Write to TIMx CCER */
    742            TIMx->CCER = tmpccer;
    743          }
    744          
    745          /**
    746            * @brief  Initializes the TIMx Channel2 according to the specified parameters 
    747            *         in the TIM_OCInitStruct.
    748            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
    749            *         peripheral.
    750            * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
    751            *         the configuration information for the specified TIM peripheral.
    752            * @retval None
    753            */
    754          void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
    755          {
    756            uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
    757             
    758            /* Check the parameters */
    759            assert_param(IS_TIM_LIST2_PERIPH(TIMx)); 
    760            assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
    761            assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
    762            assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
    763          
    764            /* Disable the Channel 2: Reset the CC2E Bit */
    765            TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
    766            
    767            /* Get the TIMx CCER register value */  
    768            tmpccer = TIMx->CCER;
    769            /* Get the TIMx CR2 register value */
    770            tmpcr2 =  TIMx->CR2;
    771            
    772            /* Get the TIMx CCMR1 register value */
    773            tmpccmrx = TIMx->CCMR1;
    774              
    775            /* Reset the Output Compare mode and Capture/Compare selection Bits */
    776            tmpccmrx &= (uint16_t)~TIM_CCMR1_OC2M;
    777            tmpccmrx &= (uint16_t)~TIM_CCMR1_CC2S;
    778            
    779            /* Select the Output Compare Mode */
    780            tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
    781            
    782            /* Reset the Output Polarity level */
    783            tmpccer &= (uint16_t)~TIM_CCER_CC2P;
    784            /* Set the Output Compare Polarity */
    785            tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
    786            
    787            /* Set the Output State */
    788            tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);
    789              
    790            if((TIMx == TIM1) || (TIMx == TIM8))
    791            {
    792              assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
    793              assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    794              assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    795              assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    796              
    797              /* Reset the Output N Polarity level */
    798              tmpccer &= (uint16_t)~TIM_CCER_CC2NP;
    799              /* Set the Output N Polarity */
    800              tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
    801              /* Reset the Output N State */
    802              tmpccer &= (uint16_t)~TIM_CCER_CC2NE;
    803              
    804              /* Set the Output N State */
    805              tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 4);
    806              /* Reset the Output Compare and Output Compare N IDLE State */
    807              tmpcr2 &= (uint16_t)~TIM_CR2_OIS2;
    808              tmpcr2 &= (uint16_t)~TIM_CR2_OIS2N;
    809              /* Set the Output Idle state */
    810              tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 2);
    811              /* Set the Output N Idle state */
    812              tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 2);
    813            }
    814            /* Write to TIMx CR2 */
    815            TIMx->CR2 = tmpcr2;
    816            
    817            /* Write to TIMx CCMR1 */
    818            TIMx->CCMR1 = tmpccmrx;
    819            
    820            /* Set the Capture Compare Register value */
    821            TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
    822            
    823            /* Write to TIMx CCER */
    824            TIMx->CCER = tmpccer;
    825          }
    826          
    827          /**
    828            * @brief  Initializes the TIMx Channel3 according to the specified parameters
    829            *         in the TIM_OCInitStruct.
    830            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
    831            * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
    832            *         the configuration information for the specified TIM peripheral.
    833            * @retval None
    834            */
    835          void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
    836          {
    837            uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
    838             
    839            /* Check the parameters */
    840            assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
    841            assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
    842            assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
    843            assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
    844          
    845            /* Disable the Channel 3: Reset the CC2E Bit */
    846            TIMx->CCER &= (uint16_t)~TIM_CCER_CC3E;
    847            
    848            /* Get the TIMx CCER register value */
    849            tmpccer = TIMx->CCER;
    850            /* Get the TIMx CR2 register value */
    851            tmpcr2 =  TIMx->CR2;
    852            
    853            /* Get the TIMx CCMR2 register value */
    854            tmpccmrx = TIMx->CCMR2;
    855              
    856            /* Reset the Output Compare mode and Capture/Compare selection Bits */
    857            tmpccmrx &= (uint16_t)~TIM_CCMR2_OC3M;
    858            tmpccmrx &= (uint16_t)~TIM_CCMR2_CC3S;  
    859            /* Select the Output Compare Mode */
    860            tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
    861            
    862            /* Reset the Output Polarity level */
    863            tmpccer &= (uint16_t)~TIM_CCER_CC3P;
    864            /* Set the Output Compare Polarity */
    865            tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
    866            
    867            /* Set the Output State */
    868            tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 8);
    869              
    870            if((TIMx == TIM1) || (TIMx == TIM8))
    871            {
    872              assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
    873              assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    874              assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    875              assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    876              
    877              /* Reset the Output N Polarity level */
    878              tmpccer &= (uint16_t)~TIM_CCER_CC3NP;
    879              /* Set the Output N Polarity */
    880              tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
    881              /* Reset the Output N State */
    882              tmpccer &= (uint16_t)~TIM_CCER_CC3NE;
    883              
    884              /* Set the Output N State */
    885              tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 8);
    886              /* Reset the Output Compare and Output Compare N IDLE State */
    887              tmpcr2 &= (uint16_t)~TIM_CR2_OIS3;
    888              tmpcr2 &= (uint16_t)~TIM_CR2_OIS3N;
    889              /* Set the Output Idle state */
    890              tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 4);
    891              /* Set the Output N Idle state */
    892              tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 4);
    893            }
    894            /* Write to TIMx CR2 */
    895            TIMx->CR2 = tmpcr2;
    896            
    897            /* Write to TIMx CCMR2 */
    898            TIMx->CCMR2 = tmpccmrx;
    899            
    900            /* Set the Capture Compare Register value */
    901            TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
    902            
    903            /* Write to TIMx CCER */
    904            TIMx->CCER = tmpccer;
    905          }
    906          
    907          /**
    908            * @brief  Initializes the TIMx Channel4 according to the specified parameters
    909            *         in the TIM_OCInitStruct.
    910            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
    911            * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
    912            *         the configuration information for the specified TIM peripheral.
    913            * @retval None
    914            */
    915          void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
    916          {
    917            uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
    918             
    919            /* Check the parameters */
    920            assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
    921            assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
    922            assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
    923            assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
    924          
    925            /* Disable the Channel 4: Reset the CC4E Bit */
    926            TIMx->CCER &= (uint16_t)~TIM_CCER_CC4E;
    927            
    928            /* Get the TIMx CCER register value */
    929            tmpccer = TIMx->CCER;
    930            /* Get the TIMx CR2 register value */
    931            tmpcr2 =  TIMx->CR2;
    932            
    933            /* Get the TIMx CCMR2 register value */
    934            tmpccmrx = TIMx->CCMR2;
    935              
    936            /* Reset the Output Compare mode and Capture/Compare selection Bits */
    937            tmpccmrx &= (uint16_t)~TIM_CCMR2_OC4M;
    938            tmpccmrx &= (uint16_t)~TIM_CCMR2_CC4S;
    939            
    940            /* Select the Output Compare Mode */
    941            tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
    942            
    943            /* Reset the Output Polarity level */
    944            tmpccer &= (uint16_t)~TIM_CCER_CC4P;
    945            /* Set the Output Compare Polarity */
    946            tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
    947            
    948            /* Set the Output State */
    949            tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);
    950            
    951            if((TIMx == TIM1) || (TIMx == TIM8))
    952            {
    953              assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    954              /* Reset the Output Compare IDLE State */
    955              tmpcr2 &=(uint16_t) ~TIM_CR2_OIS4;
    956              /* Set the Output Idle state */
    957              tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 6);
    958            }
    959            /* Write to TIMx CR2 */
    960            TIMx->CR2 = tmpcr2;
    961            
    962            /* Write to TIMx CCMR2 */  
    963            TIMx->CCMR2 = tmpccmrx;
    964              
    965            /* Set the Capture Compare Register value */
    966            TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
    967            
    968            /* Write to TIMx CCER */
    969            TIMx->CCER = tmpccer;
    970          }
    971          
    972          /**
    973            * @brief  Fills each TIM_OCInitStruct member with its default value.
    974            * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure which will
    975            *         be initialized.
    976            * @retval None
    977            */
    978          void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
    979          {
    980            /* Set the default configuration */
    981            TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
    982            TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;
    983            TIM_OCInitStruct->TIM_OutputNState = TIM_OutputNState_Disable;
    984            TIM_OCInitStruct->TIM_Pulse = 0x00000000;
    985            TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
    986            TIM_OCInitStruct->TIM_OCNPolarity = TIM_OCPolarity_High;
    987            TIM_OCInitStruct->TIM_OCIdleState = TIM_OCIdleState_Reset;
    988            TIM_OCInitStruct->TIM_OCNIdleState = TIM_OCNIdleState_Reset;
    989          }
    990          
    991          /**
    992            * @brief  Selects the TIM Output Compare Mode.
    993            * @note   This function disables the selected channel before changing the Output
    994            *         Compare Mode. If needed, user has to enable this channel using
    995            *         TIM_CCxCmd() and TIM_CCxNCmd() functions.
    996            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
    997            * @param  TIM_Channel: specifies the TIM Channel
    998            *          This parameter can be one of the following values:
    999            *            @arg TIM_Channel_1: TIM Channel 1
   1000            *            @arg TIM_Channel_2: TIM Channel 2
   1001            *            @arg TIM_Channel_3: TIM Channel 3
   1002            *            @arg TIM_Channel_4: TIM Channel 4
   1003            * @param  TIM_OCMode: specifies the TIM Output Compare Mode.
   1004            *           This parameter can be one of the following values:
   1005            *            @arg TIM_OCMode_Timing
   1006            *            @arg TIM_OCMode_Active
   1007            *            @arg TIM_OCMode_Toggle
   1008            *            @arg TIM_OCMode_PWM1
   1009            *            @arg TIM_OCMode_PWM2
   1010            *            @arg TIM_ForcedAction_Active
   1011            *            @arg TIM_ForcedAction_InActive
   1012            * @retval None
   1013            */
   1014          void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode)
   1015          {
   1016            uint32_t tmp = 0;
   1017            uint16_t tmp1 = 0;
   1018          
   1019            /* Check the parameters */
   1020            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   1021            assert_param(IS_TIM_CHANNEL(TIM_Channel));
   1022            assert_param(IS_TIM_OCM(TIM_OCMode));
   1023          
   1024            tmp = (uint32_t) TIMx;
   1025            tmp += CCMR_OFFSET;
   1026          
   1027            tmp1 = CCER_CCE_SET << (uint16_t)TIM_Channel;
   1028          
   1029            /* Disable the Channel: Reset the CCxE Bit */
   1030            TIMx->CCER &= (uint16_t) ~tmp1;
   1031          
   1032            if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
   1033            {
   1034              tmp += (TIM_Channel>>1);
   1035          
   1036              /* Reset the OCxM bits in the CCMRx register */
   1037              *(__IO uint32_t *) tmp &= CCMR_OC13M_MASK;
   1038             
   1039              /* Configure the OCxM bits in the CCMRx register */
   1040              *(__IO uint32_t *) tmp |= TIM_OCMode;
   1041            }
   1042            else
   1043            {
   1044              tmp += (uint16_t)(TIM_Channel - (uint16_t)4)>> (uint16_t)1;
   1045          
   1046              /* Reset the OCxM bits in the CCMRx register */
   1047              *(__IO uint32_t *) tmp &= CCMR_OC24M_MASK;
   1048              
   1049              /* Configure the OCxM bits in the CCMRx register */
   1050              *(__IO uint32_t *) tmp |= (uint16_t)(TIM_OCMode << 8);
   1051            }
   1052          }
   1053          
   1054          /**
   1055            * @brief  Sets the TIMx Capture Compare1 Register value
   1056            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
   1057            * @param  Compare1: specifies the Capture Compare1 register new value.
   1058            * @retval None
   1059            */
   1060          void TIM_SetCompare1(TIM_TypeDef* TIMx, uint32_t Compare1)
   1061          {
   1062            /* Check the parameters */
   1063            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   1064          
   1065            /* Set the Capture Compare1 Register value */
   1066            TIMx->CCR1 = Compare1;
   1067          }
   1068          
   1069          /**
   1070            * @brief  Sets the TIMx Capture Compare2 Register value
   1071            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   1072            *         peripheral.
   1073            * @param  Compare2: specifies the Capture Compare2 register new value.
   1074            * @retval None
   1075            */
   1076          void TIM_SetCompare2(TIM_TypeDef* TIMx, uint32_t Compare2)
   1077          {
   1078            /* Check the parameters */
   1079            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   1080          
   1081            /* Set the Capture Compare2 Register value */
   1082            TIMx->CCR2 = Compare2;
   1083          }
   1084          
   1085          /**
   1086            * @brief  Sets the TIMx Capture Compare3 Register value
   1087            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1088            * @param  Compare3: specifies the Capture Compare3 register new value.
   1089            * @retval None
   1090            */
   1091          void TIM_SetCompare3(TIM_TypeDef* TIMx, uint32_t Compare3)
   1092          {
   1093            /* Check the parameters */
   1094            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1095          
   1096            /* Set the Capture Compare3 Register value */
   1097            TIMx->CCR3 = Compare3;
   1098          }
   1099          
   1100          /**
   1101            * @brief  Sets the TIMx Capture Compare4 Register value
   1102            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1103            * @param  Compare4: specifies the Capture Compare4 register new value.
   1104            * @retval None
   1105            */
   1106          void TIM_SetCompare4(TIM_TypeDef* TIMx, uint32_t Compare4)
   1107          {
   1108            /* Check the parameters */
   1109            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1110          
   1111            /* Set the Capture Compare4 Register value */
   1112            TIMx->CCR4 = Compare4;
   1113          }
   1114          
   1115          /**
   1116            * @brief  Forces the TIMx output 1 waveform to active or inactive level.
   1117            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
   1118            * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
   1119            *          This parameter can be one of the following values:
   1120            *            @arg TIM_ForcedAction_Active: Force active level on OC1REF
   1121            *            @arg TIM_ForcedAction_InActive: Force inactive level on OC1REF.
   1122            * @retval None
   1123            */
   1124          void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
   1125          {
   1126            uint16_t tmpccmr1 = 0;
   1127          
   1128            /* Check the parameters */
   1129            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   1130            assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
   1131            tmpccmr1 = TIMx->CCMR1;
   1132          
   1133            /* Reset the OC1M Bits */
   1134            tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC1M;
   1135          
   1136            /* Configure The Forced output Mode */
   1137            tmpccmr1 |= TIM_ForcedAction;
   1138          
   1139            /* Write to TIMx CCMR1 register */
   1140            TIMx->CCMR1 = tmpccmr1;
   1141          }
   1142          
   1143          /**
   1144            * @brief  Forces the TIMx output 2 waveform to active or inactive level.
   1145            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   1146            *         peripheral.
   1147            * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
   1148            *          This parameter can be one of the following values:
   1149            *            @arg TIM_ForcedAction_Active: Force active level on OC2REF
   1150            *            @arg TIM_ForcedAction_InActive: Force inactive level on OC2REF.
   1151            * @retval None
   1152            */
   1153          void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
   1154          {
   1155            uint16_t tmpccmr1 = 0;
   1156          
   1157            /* Check the parameters */
   1158            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   1159            assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
   1160            tmpccmr1 = TIMx->CCMR1;
   1161          
   1162            /* Reset the OC2M Bits */
   1163            tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC2M;
   1164          
   1165            /* Configure The Forced output Mode */
   1166            tmpccmr1 |= (uint16_t)(TIM_ForcedAction << 8);
   1167          
   1168            /* Write to TIMx CCMR1 register */
   1169            TIMx->CCMR1 = tmpccmr1;
   1170          }
   1171          
   1172          /**
   1173            * @brief  Forces the TIMx output 3 waveform to active or inactive level.
   1174            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1175            * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
   1176            *          This parameter can be one of the following values:
   1177            *            @arg TIM_ForcedAction_Active: Force active level on OC3REF
   1178            *            @arg TIM_ForcedAction_InActive: Force inactive level on OC3REF.
   1179            * @retval None
   1180            */
   1181          void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
   1182          {
   1183            uint16_t tmpccmr2 = 0;
   1184          
   1185            /* Check the parameters */
   1186            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1187            assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
   1188          
   1189            tmpccmr2 = TIMx->CCMR2;
   1190          
   1191            /* Reset the OC1M Bits */
   1192            tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC3M;
   1193          
   1194            /* Configure The Forced output Mode */
   1195            tmpccmr2 |= TIM_ForcedAction;
   1196          
   1197            /* Write to TIMx CCMR2 register */
   1198            TIMx->CCMR2 = tmpccmr2;
   1199          }
   1200          
   1201          /**
   1202            * @brief  Forces the TIMx output 4 waveform to active or inactive level.
   1203            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1204            * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
   1205            *          This parameter can be one of the following values:
   1206            *            @arg TIM_ForcedAction_Active: Force active level on OC4REF
   1207            *            @arg TIM_ForcedAction_InActive: Force inactive level on OC4REF.
   1208            * @retval None
   1209            */
   1210          void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
   1211          {
   1212            uint16_t tmpccmr2 = 0;
   1213          
   1214            /* Check the parameters */
   1215            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1216            assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
   1217            tmpccmr2 = TIMx->CCMR2;
   1218          
   1219            /* Reset the OC2M Bits */
   1220            tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC4M;
   1221          
   1222            /* Configure The Forced output Mode */
   1223            tmpccmr2 |= (uint16_t)(TIM_ForcedAction << 8);
   1224          
   1225            /* Write to TIMx CCMR2 register */
   1226            TIMx->CCMR2 = tmpccmr2;
   1227          }
   1228          
   1229          /**
   1230            * @brief  Enables or disables the TIMx peripheral Preload register on CCR1.
   1231            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
   1232            * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
   1233            *          This parameter can be one of the following values:
   1234            *            @arg TIM_OCPreload_Enable
   1235            *            @arg TIM_OCPreload_Disable
   1236            * @retval None
   1237            */
   1238          void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
   1239          {
   1240            uint16_t tmpccmr1 = 0;
   1241          
   1242            /* Check the parameters */
   1243            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   1244            assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1245          
   1246            tmpccmr1 = TIMx->CCMR1;
   1247          
   1248            /* Reset the OC1PE Bit */
   1249            tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC1PE);
   1250          
   1251            /* Enable or Disable the Output Compare Preload feature */
   1252            tmpccmr1 |= TIM_OCPreload;
   1253          
   1254            /* Write to TIMx CCMR1 register */
   1255            TIMx->CCMR1 = tmpccmr1;
   1256          }
   1257          
   1258          /**
   1259            * @brief  Enables or disables the TIMx peripheral Preload register on CCR2.
   1260            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   1261            *         peripheral.
   1262            * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
   1263            *          This parameter can be one of the following values:
   1264            *            @arg TIM_OCPreload_Enable
   1265            *            @arg TIM_OCPreload_Disable
   1266            * @retval None
   1267            */
   1268          void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
   1269          {
   1270            uint16_t tmpccmr1 = 0;
   1271          
   1272            /* Check the parameters */
   1273            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   1274            assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1275          
   1276            tmpccmr1 = TIMx->CCMR1;
   1277          
   1278            /* Reset the OC2PE Bit */
   1279            tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC2PE);
   1280          
   1281            /* Enable or Disable the Output Compare Preload feature */
   1282            tmpccmr1 |= (uint16_t)(TIM_OCPreload << 8);
   1283          
   1284            /* Write to TIMx CCMR1 register */
   1285            TIMx->CCMR1 = tmpccmr1;
   1286          }
   1287          
   1288          /**
   1289            * @brief  Enables or disables the TIMx peripheral Preload register on CCR3.
   1290            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1291            * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
   1292            *          This parameter can be one of the following values:
   1293            *            @arg TIM_OCPreload_Enable
   1294            *            @arg TIM_OCPreload_Disable
   1295            * @retval None
   1296            */
   1297          void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
   1298          {
   1299            uint16_t tmpccmr2 = 0;
   1300          
   1301            /* Check the parameters */
   1302            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1303            assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1304          
   1305            tmpccmr2 = TIMx->CCMR2;
   1306          
   1307            /* Reset the OC3PE Bit */
   1308            tmpccmr2 &= (uint16_t)(~TIM_CCMR2_OC3PE);
   1309          
   1310            /* Enable or Disable the Output Compare Preload feature */
   1311            tmpccmr2 |= TIM_OCPreload;
   1312          
   1313            /* Write to TIMx CCMR2 register */
   1314            TIMx->CCMR2 = tmpccmr2;
   1315          }
   1316          
   1317          /**
   1318            * @brief  Enables or disables the TIMx peripheral Preload register on CCR4.
   1319            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1320            * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
   1321            *          This parameter can be one of the following values:
   1322            *            @arg TIM_OCPreload_Enable
   1323            *            @arg TIM_OCPreload_Disable
   1324            * @retval None
   1325            */
   1326          void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
   1327          {
   1328            uint16_t tmpccmr2 = 0;
   1329          
   1330            /* Check the parameters */
   1331            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1332            assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1333          
   1334            tmpccmr2 = TIMx->CCMR2;
   1335          
   1336            /* Reset the OC4PE Bit */
   1337            tmpccmr2 &= (uint16_t)(~TIM_CCMR2_OC4PE);
   1338          
   1339            /* Enable or Disable the Output Compare Preload feature */
   1340            tmpccmr2 |= (uint16_t)(TIM_OCPreload << 8);
   1341          
   1342            /* Write to TIMx CCMR2 register */
   1343            TIMx->CCMR2 = tmpccmr2;
   1344          }
   1345          
   1346          /**
   1347            * @brief  Configures the TIMx Output Compare 1 Fast feature.
   1348            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
   1349            * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1350            *          This parameter can be one of the following values:
   1351            *            @arg TIM_OCFast_Enable: TIM output compare fast enable
   1352            *            @arg TIM_OCFast_Disable: TIM output compare fast disable
   1353            * @retval None
   1354            */
   1355          void TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
   1356          {
   1357            uint16_t tmpccmr1 = 0;
   1358          
   1359            /* Check the parameters */
   1360            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   1361            assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1362          
   1363            /* Get the TIMx CCMR1 register value */
   1364            tmpccmr1 = TIMx->CCMR1;
   1365          
   1366            /* Reset the OC1FE Bit */
   1367            tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC1FE;
   1368          
   1369            /* Enable or Disable the Output Compare Fast Bit */
   1370            tmpccmr1 |= TIM_OCFast;
   1371          
   1372            /* Write to TIMx CCMR1 */
   1373            TIMx->CCMR1 = tmpccmr1;
   1374          }
   1375          
   1376          /**
   1377            * @brief  Configures the TIMx Output Compare 2 Fast feature.
   1378            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   1379            *         peripheral.
   1380            * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1381            *          This parameter can be one of the following values:
   1382            *            @arg TIM_OCFast_Enable: TIM output compare fast enable
   1383            *            @arg TIM_OCFast_Disable: TIM output compare fast disable
   1384            * @retval None
   1385            */
   1386          void TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
   1387          {
   1388            uint16_t tmpccmr1 = 0;
   1389          
   1390            /* Check the parameters */
   1391            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   1392            assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1393          
   1394            /* Get the TIMx CCMR1 register value */
   1395            tmpccmr1 = TIMx->CCMR1;
   1396          
   1397            /* Reset the OC2FE Bit */
   1398            tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC2FE);
   1399          
   1400            /* Enable or Disable the Output Compare Fast Bit */
   1401            tmpccmr1 |= (uint16_t)(TIM_OCFast << 8);
   1402          
   1403            /* Write to TIMx CCMR1 */
   1404            TIMx->CCMR1 = tmpccmr1;
   1405          }
   1406          
   1407          /**
   1408            * @brief  Configures the TIMx Output Compare 3 Fast feature.
   1409            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1410            * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1411            *          This parameter can be one of the following values:
   1412            *            @arg TIM_OCFast_Enable: TIM output compare fast enable
   1413            *            @arg TIM_OCFast_Disable: TIM output compare fast disable
   1414            * @retval None
   1415            */
   1416          void TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
   1417          {
   1418            uint16_t tmpccmr2 = 0;
   1419            
   1420            /* Check the parameters */
   1421            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1422            assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1423          
   1424            /* Get the TIMx CCMR2 register value */
   1425            tmpccmr2 = TIMx->CCMR2;
   1426          
   1427            /* Reset the OC3FE Bit */
   1428            tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC3FE;
   1429          
   1430            /* Enable or Disable the Output Compare Fast Bit */
   1431            tmpccmr2 |= TIM_OCFast;
   1432          
   1433            /* Write to TIMx CCMR2 */
   1434            TIMx->CCMR2 = tmpccmr2;
   1435          }
   1436          
   1437          /**
   1438            * @brief  Configures the TIMx Output Compare 4 Fast feature.
   1439            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1440            * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1441            *          This parameter can be one of the following values:
   1442            *            @arg TIM_OCFast_Enable: TIM output compare fast enable
   1443            *            @arg TIM_OCFast_Disable: TIM output compare fast disable
   1444            * @retval None
   1445            */
   1446          void TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
   1447          {
   1448            uint16_t tmpccmr2 = 0;
   1449          
   1450            /* Check the parameters */
   1451            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1452            assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1453          
   1454            /* Get the TIMx CCMR2 register value */
   1455            tmpccmr2 = TIMx->CCMR2;
   1456          
   1457            /* Reset the OC4FE Bit */
   1458            tmpccmr2 &= (uint16_t)(~TIM_CCMR2_OC4FE);
   1459          
   1460            /* Enable or Disable the Output Compare Fast Bit */
   1461            tmpccmr2 |= (uint16_t)(TIM_OCFast << 8);
   1462          
   1463            /* Write to TIMx CCMR2 */
   1464            TIMx->CCMR2 = tmpccmr2;
   1465          }
   1466          
   1467          /**
   1468            * @brief  Clears or safeguards the OCREF1 signal on an external event
   1469            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
   1470            * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1471            *          This parameter can be one of the following values:
   1472            *            @arg TIM_OCClear_Enable: TIM Output clear enable
   1473            *            @arg TIM_OCClear_Disable: TIM Output clear disable
   1474            * @retval None
   1475            */
   1476          void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
   1477          {
   1478            uint16_t tmpccmr1 = 0;
   1479          
   1480            /* Check the parameters */
   1481            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   1482            assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   1483          
   1484            tmpccmr1 = TIMx->CCMR1;
   1485          
   1486            /* Reset the OC1CE Bit */
   1487            tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC1CE;
   1488          
   1489            /* Enable or Disable the Output Compare Clear Bit */
   1490            tmpccmr1 |= TIM_OCClear;
   1491          
   1492            /* Write to TIMx CCMR1 register */
   1493            TIMx->CCMR1 = tmpccmr1;
   1494          }
   1495          
   1496          /**
   1497            * @brief  Clears or safeguards the OCREF2 signal on an external event
   1498            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   1499            *         peripheral.
   1500            * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1501            *          This parameter can be one of the following values:
   1502            *            @arg TIM_OCClear_Enable: TIM Output clear enable
   1503            *            @arg TIM_OCClear_Disable: TIM Output clear disable
   1504            * @retval None
   1505            */
   1506          void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
   1507          {
   1508            uint16_t tmpccmr1 = 0;
   1509          
   1510            /* Check the parameters */
   1511            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   1512            assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   1513          
   1514            tmpccmr1 = TIMx->CCMR1;
   1515          
   1516            /* Reset the OC2CE Bit */
   1517            tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC2CE;
   1518          
   1519            /* Enable or Disable the Output Compare Clear Bit */
   1520            tmpccmr1 |= (uint16_t)(TIM_OCClear << 8);
   1521          
   1522            /* Write to TIMx CCMR1 register */
   1523            TIMx->CCMR1 = tmpccmr1;
   1524          }
   1525          
   1526          /**
   1527            * @brief  Clears or safeguards the OCREF3 signal on an external event
   1528            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1529            * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1530            *          This parameter can be one of the following values:
   1531            *            @arg TIM_OCClear_Enable: TIM Output clear enable
   1532            *            @arg TIM_OCClear_Disable: TIM Output clear disable
   1533            * @retval None
   1534            */
   1535          void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
   1536          {
   1537            uint16_t tmpccmr2 = 0;
   1538          
   1539            /* Check the parameters */
   1540            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1541            assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   1542          
   1543            tmpccmr2 = TIMx->CCMR2;
   1544          
   1545            /* Reset the OC3CE Bit */
   1546            tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC3CE;
   1547          
   1548            /* Enable or Disable the Output Compare Clear Bit */
   1549            tmpccmr2 |= TIM_OCClear;
   1550          
   1551            /* Write to TIMx CCMR2 register */
   1552            TIMx->CCMR2 = tmpccmr2;
   1553          }
   1554          
   1555          /**
   1556            * @brief  Clears or safeguards the OCREF4 signal on an external event
   1557            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1558            * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1559            *          This parameter can be one of the following values:
   1560            *            @arg TIM_OCClear_Enable: TIM Output clear enable
   1561            *            @arg TIM_OCClear_Disable: TIM Output clear disable
   1562            * @retval None
   1563            */
   1564          void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
   1565          {
   1566            uint16_t tmpccmr2 = 0;
   1567          
   1568            /* Check the parameters */
   1569            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1570            assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   1571          
   1572            tmpccmr2 = TIMx->CCMR2;
   1573          
   1574            /* Reset the OC4CE Bit */
   1575            tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC4CE;
   1576          
   1577            /* Enable or Disable the Output Compare Clear Bit */
   1578            tmpccmr2 |= (uint16_t)(TIM_OCClear << 8);
   1579          
   1580            /* Write to TIMx CCMR2 register */
   1581            TIMx->CCMR2 = tmpccmr2;
   1582          }
   1583          
   1584          /**
   1585            * @brief  Configures the TIMx channel 1 polarity.
   1586            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
   1587            * @param  TIM_OCPolarity: specifies the OC1 Polarity
   1588            *          This parameter can be one of the following values:
   1589            *            @arg TIM_OCPolarity_High: Output Compare active high
   1590            *            @arg TIM_OCPolarity_Low: Output Compare active low
   1591            * @retval None
   1592            */
   1593          void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
   1594          {
   1595            uint16_t tmpccer = 0;
   1596          
   1597            /* Check the parameters */
   1598            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   1599            assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   1600          
   1601            tmpccer = TIMx->CCER;
   1602          
   1603            /* Set or Reset the CC1P Bit */
   1604            tmpccer &= (uint16_t)(~TIM_CCER_CC1P);
   1605            tmpccer |= TIM_OCPolarity;
   1606          
   1607            /* Write to TIMx CCER register */
   1608            TIMx->CCER = tmpccer;
   1609          }
   1610          
   1611          /**
   1612            * @brief  Configures the TIMx Channel 1N polarity.
   1613            * @param  TIMx: where x can be 1 or 8 to select the TIM peripheral.
   1614            * @param  TIM_OCNPolarity: specifies the OC1N Polarity
   1615            *          This parameter can be one of the following values:
   1616            *            @arg TIM_OCNPolarity_High: Output Compare active high
   1617            *            @arg TIM_OCNPolarity_Low: Output Compare active low
   1618            * @retval None
   1619            */
   1620          void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
   1621          {
   1622            uint16_t tmpccer = 0;
   1623            /* Check the parameters */
   1624            assert_param(IS_TIM_LIST4_PERIPH(TIMx));
   1625            assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
   1626             
   1627            tmpccer = TIMx->CCER;
   1628          
   1629            /* Set or Reset the CC1NP Bit */
   1630            tmpccer &= (uint16_t)~TIM_CCER_CC1NP;
   1631            tmpccer |= TIM_OCNPolarity;
   1632          
   1633            /* Write to TIMx CCER register */
   1634            TIMx->CCER = tmpccer;
   1635          }
   1636          
   1637          /**
   1638            * @brief  Configures the TIMx channel 2 polarity.
   1639            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   1640            *         peripheral.
   1641            * @param  TIM_OCPolarity: specifies the OC2 Polarity
   1642            *          This parameter can be one of the following values:
   1643            *            @arg TIM_OCPolarity_High: Output Compare active high
   1644            *            @arg TIM_OCPolarity_Low: Output Compare active low
   1645            * @retval None
   1646            */
   1647          void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
   1648          {
   1649            uint16_t tmpccer = 0;
   1650          
   1651            /* Check the parameters */
   1652            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   1653            assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   1654          
   1655            tmpccer = TIMx->CCER;
   1656          
   1657            /* Set or Reset the CC2P Bit */
   1658            tmpccer &= (uint16_t)(~TIM_CCER_CC2P);
   1659            tmpccer |= (uint16_t)(TIM_OCPolarity << 4);
   1660          
   1661            /* Write to TIMx CCER register */
   1662            TIMx->CCER = tmpccer;
   1663          }
   1664          
   1665          /**
   1666            * @brief  Configures the TIMx Channel 2N polarity.
   1667            * @param  TIMx: where x can be 1 or 8 to select the TIM peripheral.
   1668            * @param  TIM_OCNPolarity: specifies the OC2N Polarity
   1669            *          This parameter can be one of the following values:
   1670            *            @arg TIM_OCNPolarity_High: Output Compare active high
   1671            *            @arg TIM_OCNPolarity_Low: Output Compare active low
   1672            * @retval None
   1673            */
   1674          void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
   1675          {
   1676            uint16_t tmpccer = 0;
   1677          
   1678            /* Check the parameters */
   1679            assert_param(IS_TIM_LIST4_PERIPH(TIMx));
   1680            assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
   1681            
   1682            tmpccer = TIMx->CCER;
   1683          
   1684            /* Set or Reset the CC2NP Bit */
   1685            tmpccer &= (uint16_t)~TIM_CCER_CC2NP;
   1686            tmpccer |= (uint16_t)(TIM_OCNPolarity << 4);
   1687          
   1688            /* Write to TIMx CCER register */
   1689            TIMx->CCER = tmpccer;
   1690          }
   1691          
   1692          /**
   1693            * @brief  Configures the TIMx channel 3 polarity.
   1694            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1695            * @param  TIM_OCPolarity: specifies the OC3 Polarity
   1696            *          This parameter can be one of the following values:
   1697            *            @arg TIM_OCPolarity_High: Output Compare active high
   1698            *            @arg TIM_OCPolarity_Low: Output Compare active low
   1699            * @retval None
   1700            */
   1701          void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
   1702          {
   1703            uint16_t tmpccer = 0;
   1704          
   1705            /* Check the parameters */
   1706            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1707            assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   1708          
   1709            tmpccer = TIMx->CCER;
   1710          
   1711            /* Set or Reset the CC3P Bit */
   1712            tmpccer &= (uint16_t)~TIM_CCER_CC3P;
   1713            tmpccer |= (uint16_t)(TIM_OCPolarity << 8);
   1714          
   1715            /* Write to TIMx CCER register */
   1716            TIMx->CCER = tmpccer;
   1717          }
   1718          
   1719          /**
   1720            * @brief  Configures the TIMx Channel 3N polarity.
   1721            * @param  TIMx: where x can be 1 or 8 to select the TIM peripheral.
   1722            * @param  TIM_OCNPolarity: specifies the OC3N Polarity
   1723            *          This parameter can be one of the following values:
   1724            *            @arg TIM_OCNPolarity_High: Output Compare active high
   1725            *            @arg TIM_OCNPolarity_Low: Output Compare active low
   1726            * @retval None
   1727            */
   1728          void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
   1729          {
   1730            uint16_t tmpccer = 0;
   1731           
   1732            /* Check the parameters */
   1733            assert_param(IS_TIM_LIST4_PERIPH(TIMx));
   1734            assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
   1735              
   1736            tmpccer = TIMx->CCER;
   1737          
   1738            /* Set or Reset the CC3NP Bit */
   1739            tmpccer &= (uint16_t)~TIM_CCER_CC3NP;
   1740            tmpccer |= (uint16_t)(TIM_OCNPolarity << 8);
   1741          
   1742            /* Write to TIMx CCER register */
   1743            TIMx->CCER = tmpccer;
   1744          }
   1745          
   1746          /**
   1747            * @brief  Configures the TIMx channel 4 polarity.
   1748            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1749            * @param  TIM_OCPolarity: specifies the OC4 Polarity
   1750            *          This parameter can be one of the following values:
   1751            *            @arg TIM_OCPolarity_High: Output Compare active high
   1752            *            @arg TIM_OCPolarity_Low: Output Compare active low
   1753            * @retval None
   1754            */
   1755          void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
   1756          {
   1757            uint16_t tmpccer = 0;
   1758          
   1759            /* Check the parameters */
   1760            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1761            assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   1762          
   1763            tmpccer = TIMx->CCER;
   1764          
   1765            /* Set or Reset the CC4P Bit */
   1766            tmpccer &= (uint16_t)~TIM_CCER_CC4P;
   1767            tmpccer |= (uint16_t)(TIM_OCPolarity << 12);
   1768          
   1769            /* Write to TIMx CCER register */
   1770            TIMx->CCER = tmpccer;
   1771          }
   1772          
   1773          /**
   1774            * @brief  Enables or disables the TIM Capture Compare Channel x.
   1775            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
   1776            * @param  TIM_Channel: specifies the TIM Channel
   1777            *          This parameter can be one of the following values:
   1778            *            @arg TIM_Channel_1: TIM Channel 1
   1779            *            @arg TIM_Channel_2: TIM Channel 2
   1780            *            @arg TIM_Channel_3: TIM Channel 3
   1781            *            @arg TIM_Channel_4: TIM Channel 4
   1782            * @param  TIM_CCx: specifies the TIM Channel CCxE bit new state.
   1783            *          This parameter can be: TIM_CCx_Enable or TIM_CCx_Disable. 
   1784            * @retval None
   1785            */
   1786          void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx)
   1787          {
   1788            uint16_t tmp = 0;
   1789          
   1790            /* Check the parameters */
   1791            assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
   1792            assert_param(IS_TIM_CHANNEL(TIM_Channel));
   1793            assert_param(IS_TIM_CCX(TIM_CCx));
   1794          
   1795            tmp = CCER_CCE_SET << TIM_Channel;
   1796          
   1797            /* Reset the CCxE Bit */
   1798            TIMx->CCER &= (uint16_t)~ tmp;
   1799          
   1800            /* Set or reset the CCxE Bit */ 
   1801            TIMx->CCER |=  (uint16_t)(TIM_CCx << TIM_Channel);
   1802          }
   1803          
   1804          /**
   1805            * @brief  Enables or disables the TIM Capture Compare Channel xN.
   1806            * @param  TIMx: where x can be 1 or 8 to select the TIM peripheral.
   1807            * @param  TIM_Channel: specifies the TIM Channel
   1808            *          This parameter can be one of the following values:
   1809            *            @arg TIM_Channel_1: TIM Channel 1
   1810            *            @arg TIM_Channel_2: TIM Channel 2
   1811            *            @arg TIM_Channel_3: TIM Channel 3
   1812            * @param  TIM_CCxN: specifies the TIM Channel CCxNE bit new state.
   1813            *          This parameter can be: TIM_CCxN_Enable or TIM_CCxN_Disable. 
   1814            * @retval None
   1815            */
   1816          void TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN)
   1817          {
   1818            uint16_t tmp = 0;
   1819          
   1820            /* Check the parameters */
   1821            assert_param(IS_TIM_LIST4_PERIPH(TIMx));
   1822            assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
   1823            assert_param(IS_TIM_CCXN(TIM_CCxN));
   1824          
   1825            tmp = CCER_CCNE_SET << TIM_Channel;
   1826          
   1827            /* Reset the CCxNE Bit */
   1828            TIMx->CCER &= (uint16_t) ~tmp;
   1829          
   1830            /* Set or reset the CCxNE Bit */ 
   1831            TIMx->CCER |=  (uint16_t)(TIM_CCxN << TIM_Channel);
   1832          }
   1833          /**
   1834            * @}
   1835            */
   1836          
   1837          /** @defgroup TIM_Group3 Input Capture management functions
   1838           *  @brief    Input Capture management functions 
   1839           *
   1840          @verbatim   
   1841           ===============================================================================
   1842                            ##### Input Capture management functions #####
   1843           ===============================================================================  
   1844                   
   1845                      ##### TIM Driver: how to use it in Input Capture Mode #####
   1846           ===============================================================================
   1847              [..]    
   1848              To use the Timer in Input Capture mode, the following steps are mandatory:
   1849                 
   1850                (#) Enable TIM clock using RCC_APBxPeriphClockCmd(RCC_APBxPeriph_TIMx, ENABLE) 
   1851                    function
   1852                 
   1853                (#) Configure the TIM pins by configuring the corresponding GPIO pins
   1854                 
   1855                (#) Configure the Time base unit as described in the first part of this driver,
   1856                    if needed, else the Timer will run with the default configuration:
   1857                  (++) Autoreload value = 0xFFFF
   1858                  (++) Prescaler value = 0x0000
   1859                  (++) Counter mode = Up counting
   1860                  (++) Clock Division = TIM_CKD_DIV1
   1861                    
   1862                (#) Fill the TIM_ICInitStruct with the desired parameters including:
   1863                  (++) TIM Channel: TIM_Channel
   1864                  (++) TIM Input Capture polarity: TIM_ICPolarity
   1865                  (++) TIM Input Capture selection: TIM_ICSelection
   1866                  (++) TIM Input Capture Prescaler: TIM_ICPrescaler
   1867                  (++) TIM Input Capture filter value: TIM_ICFilter
   1868                 
   1869                (#) Call TIM_ICInit(TIMx, &TIM_ICInitStruct) to configure the desired channel 
   1870                    with the corresponding configuration and to measure only frequency 
   1871                    or duty cycle of the input signal, or, Call TIM_PWMIConfig(TIMx, &TIM_ICInitStruct) 
   1872                    to configure the desired channels with the corresponding configuration 
   1873                    and to measure the frequency and the duty cycle of the input signal
   1874                    
   1875                (#) Enable the NVIC or the DMA to read the measured frequency. 
   1876                    
   1877                (#) Enable the corresponding interrupt (or DMA request) to read the Captured 
   1878                    value, using the function TIM_ITConfig(TIMx, TIM_IT_CCx) 
   1879                    (or TIM_DMA_Cmd(TIMx, TIM_DMA_CCx)) 
   1880                 
   1881                (#) Call the TIM_Cmd(ENABLE) function to enable the TIM counter.
   1882                 
   1883                (#) Use TIM_GetCapturex(TIMx); to read the captured value.
   1884                 
   1885                -@- All other functions can be used separately to modify, if needed,
   1886                    a specific feature of the Timer. 
   1887          
   1888          @endverbatim
   1889            * @{
   1890            */
   1891          
   1892          /**
   1893            * @brief  Initializes the TIM peripheral according to the specified parameters
   1894            *         in the TIM_ICInitStruct.
   1895            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
   1896            * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure that contains
   1897            *         the configuration information for the specified TIM peripheral.
   1898            * @retval None
   1899            */
   1900          void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
   1901          {
   1902            /* Check the parameters */
   1903            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   1904            assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
   1905            assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
   1906            assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
   1907            assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
   1908            
   1909            if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
   1910            {
   1911              /* TI1 Configuration */
   1912              TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
   1913                         TIM_ICInitStruct->TIM_ICSelection,
   1914                         TIM_ICInitStruct->TIM_ICFilter);
   1915              /* Set the Input Capture Prescaler value */
   1916              TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   1917            }
   1918            else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
   1919            {
   1920              /* TI2 Configuration */
   1921              assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   1922              TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
   1923                         TIM_ICInitStruct->TIM_ICSelection,
   1924                         TIM_ICInitStruct->TIM_ICFilter);
   1925              /* Set the Input Capture Prescaler value */
   1926              TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   1927            }
   1928            else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
   1929            {
   1930              /* TI3 Configuration */
   1931              assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1932              TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
   1933                         TIM_ICInitStruct->TIM_ICSelection,
   1934                         TIM_ICInitStruct->TIM_ICFilter);
   1935              /* Set the Input Capture Prescaler value */
   1936              TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   1937            }
   1938            else
   1939            {
   1940              /* TI4 Configuration */
   1941              assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1942              TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
   1943                         TIM_ICInitStruct->TIM_ICSelection,
   1944                         TIM_ICInitStruct->TIM_ICFilter);
   1945              /* Set the Input Capture Prescaler value */
   1946              TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   1947            }
   1948          }
   1949          
   1950          /**
   1951            * @brief  Fills each TIM_ICInitStruct member with its default value.
   1952            * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure which will
   1953            *         be initialized.
   1954            * @retval None
   1955            */
   1956          void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
   1957          {
   1958            /* Set the default configuration */
   1959            TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
   1960            TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
   1961            TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
   1962            TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
   1963            TIM_ICInitStruct->TIM_ICFilter = 0x00;
   1964          }
   1965          
   1966          /**
   1967            * @brief  Configures the TIM peripheral according to the specified parameters
   1968            *         in the TIM_ICInitStruct to measure an external PWM signal.
   1969            * @param  TIMx: where x can be  1, 2, 3, 4, 5,8, 9 or 12 to select the TIM 
   1970            *         peripheral.
   1971            * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure that contains
   1972            *         the configuration information for the specified TIM peripheral.
   1973            * @retval None
   1974            */
   1975          void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
   1976          {
   1977            uint16_t icoppositepolarity = TIM_ICPolarity_Rising;
   1978            uint16_t icoppositeselection = TIM_ICSelection_DirectTI;
   1979          
   1980            /* Check the parameters */
   1981            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   1982          
   1983            /* Select the Opposite Input Polarity */
   1984            if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
   1985            {
   1986              icoppositepolarity = TIM_ICPolarity_Falling;
   1987            }
   1988            else
   1989            {
   1990              icoppositepolarity = TIM_ICPolarity_Rising;
   1991            }
   1992            /* Select the Opposite Input */
   1993            if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
   1994            {
   1995              icoppositeselection = TIM_ICSelection_IndirectTI;
   1996            }
   1997            else
   1998            {
   1999              icoppositeselection = TIM_ICSelection_DirectTI;
   2000            }
   2001            if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
   2002            {
   2003              /* TI1 Configuration */
   2004              TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
   2005                         TIM_ICInitStruct->TIM_ICFilter);
   2006              /* Set the Input Capture Prescaler value */
   2007              TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   2008              /* TI2 Configuration */
   2009              TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
   2010              /* Set the Input Capture Prescaler value */
   2011              TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   2012            }
   2013            else
   2014            { 
   2015              /* TI2 Configuration */
   2016              TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
   2017                         TIM_ICInitStruct->TIM_ICFilter);
   2018              /* Set the Input Capture Prescaler value */
   2019              TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   2020              /* TI1 Configuration */
   2021              TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
   2022              /* Set the Input Capture Prescaler value */
   2023              TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   2024            }
   2025          }
   2026          
   2027          /**
   2028            * @brief  Gets the TIMx Input Capture 1 value.
   2029            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
   2030            * @retval Capture Compare 1 Register value.
   2031            */
   2032          uint32_t TIM_GetCapture1(TIM_TypeDef* TIMx)
   2033          {
   2034            /* Check the parameters */
   2035            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   2036          
   2037            /* Get the Capture 1 Register value */
   2038            return TIMx->CCR1;
   2039          }
   2040          
   2041          /**
   2042            * @brief  Gets the TIMx Input Capture 2 value.
   2043            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   2044            *         peripheral.
   2045            * @retval Capture Compare 2 Register value.
   2046            */
   2047          uint32_t TIM_GetCapture2(TIM_TypeDef* TIMx)
   2048          {
   2049            /* Check the parameters */
   2050            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   2051          
   2052            /* Get the Capture 2 Register value */
   2053            return TIMx->CCR2;
   2054          }
   2055          
   2056          /**
   2057            * @brief  Gets the TIMx Input Capture 3 value.
   2058            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2059            * @retval Capture Compare 3 Register value.
   2060            */
   2061          uint32_t TIM_GetCapture3(TIM_TypeDef* TIMx)
   2062          {
   2063            /* Check the parameters */
   2064            assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
   2065          
   2066            /* Get the Capture 3 Register value */
   2067            return TIMx->CCR3;
   2068          }
   2069          
   2070          /**
   2071            * @brief  Gets the TIMx Input Capture 4 value.
   2072            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2073            * @retval Capture Compare 4 Register value.
   2074            */
   2075          uint32_t TIM_GetCapture4(TIM_TypeDef* TIMx)
   2076          {
   2077            /* Check the parameters */
   2078            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   2079          
   2080            /* Get the Capture 4 Register value */
   2081            return TIMx->CCR4;
   2082          }
   2083          
   2084          /**
   2085            * @brief  Sets the TIMx Input Capture 1 prescaler.
   2086            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
   2087            * @param  TIM_ICPSC: specifies the Input Capture1 prescaler new value.
   2088            *          This parameter can be one of the following values:
   2089            *            @arg TIM_ICPSC_DIV1: no prescaler
   2090            *            @arg TIM_ICPSC_DIV2: capture is done once every 2 events
   2091            *            @arg TIM_ICPSC_DIV4: capture is done once every 4 events
   2092            *            @arg TIM_ICPSC_DIV8: capture is done once every 8 events
   2093            * @retval None
   2094            */
   2095          void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
   2096          {
   2097            /* Check the parameters */
   2098            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   2099            assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
   2100          
   2101            /* Reset the IC1PSC Bits */
   2102            TIMx->CCMR1 &= (uint16_t)~TIM_CCMR1_IC1PSC;
   2103          
   2104            /* Set the IC1PSC value */
   2105            TIMx->CCMR1 |= TIM_ICPSC;
   2106          }
   2107          
   2108          /**
   2109            * @brief  Sets the TIMx Input Capture 2 prescaler.
   2110            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   2111            *         peripheral.
   2112            * @param  TIM_ICPSC: specifies the Input Capture2 prescaler new value.
   2113            *          This parameter can be one of the following values:
   2114            *            @arg TIM_ICPSC_DIV1: no prescaler
   2115            *            @arg TIM_ICPSC_DIV2: capture is done once every 2 events
   2116            *            @arg TIM_ICPSC_DIV4: capture is done once every 4 events
   2117            *            @arg TIM_ICPSC_DIV8: capture is done once every 8 events
   2118            * @retval None
   2119            */
   2120          void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
   2121          {
   2122            /* Check the parameters */
   2123            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   2124            assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
   2125          
   2126            /* Reset the IC2PSC Bits */
   2127            TIMx->CCMR1 &= (uint16_t)~TIM_CCMR1_IC2PSC;
   2128          
   2129            /* Set the IC2PSC value */
   2130            TIMx->CCMR1 |= (uint16_t)(TIM_ICPSC << 8);
   2131          }
   2132          
   2133          /**
   2134            * @brief  Sets the TIMx Input Capture 3 prescaler.
   2135            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2136            * @param  TIM_ICPSC: specifies the Input Capture3 prescaler new value.
   2137            *          This parameter can be one of the following values:
   2138            *            @arg TIM_ICPSC_DIV1: no prescaler
   2139            *            @arg TIM_ICPSC_DIV2: capture is done once every 2 events
   2140            *            @arg TIM_ICPSC_DIV4: capture is done once every 4 events
   2141            *            @arg TIM_ICPSC_DIV8: capture is done once every 8 events
   2142            * @retval None
   2143            */
   2144          void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
   2145          {
   2146            /* Check the parameters */
   2147            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   2148            assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
   2149          
   2150            /* Reset the IC3PSC Bits */
   2151            TIMx->CCMR2 &= (uint16_t)~TIM_CCMR2_IC3PSC;
   2152          
   2153            /* Set the IC3PSC value */
   2154            TIMx->CCMR2 |= TIM_ICPSC;
   2155          }
   2156          
   2157          /**
   2158            * @brief  Sets the TIMx Input Capture 4 prescaler.
   2159            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2160            * @param  TIM_ICPSC: specifies the Input Capture4 prescaler new value.
   2161            *          This parameter can be one of the following values:
   2162            *            @arg TIM_ICPSC_DIV1: no prescaler
   2163            *            @arg TIM_ICPSC_DIV2: capture is done once every 2 events
   2164            *            @arg TIM_ICPSC_DIV4: capture is done once every 4 events
   2165            *            @arg TIM_ICPSC_DIV8: capture is done once every 8 events
   2166            * @retval None
   2167            */
   2168          void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
   2169          {  
   2170            /* Check the parameters */
   2171            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   2172            assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
   2173          
   2174            /* Reset the IC4PSC Bits */
   2175            TIMx->CCMR2 &= (uint16_t)~TIM_CCMR2_IC4PSC;
   2176          
   2177            /* Set the IC4PSC value */
   2178            TIMx->CCMR2 |= (uint16_t)(TIM_ICPSC << 8);
   2179          }
   2180          /**
   2181            * @}
   2182            */
   2183          
   2184          /** @defgroup TIM_Group4 Advanced-control timers (TIM1 and TIM8) specific features
   2185           *  @brief   Advanced-control timers (TIM1 and TIM8) specific features
   2186           *
   2187          @verbatim   
   2188           ===============================================================================
   2189                ##### Advanced-control timers (TIM1 and TIM8) specific features #####
   2190           ===============================================================================  
   2191                  
   2192                       ##### TIM Driver: how to use the Break feature #####
   2193           ===============================================================================
   2194              [..] 
   2195              After configuring the Timer channel(s) in the appropriate Output Compare mode: 
   2196                                   
   2197                (#) Fill the TIM_BDTRInitStruct with the desired parameters for the Timer
   2198                    Break Polarity, dead time, Lock level, the OSSI/OSSR State and the 
   2199                    AOE(automatic output enable).
   2200                         
   2201                (#) Call TIM_BDTRConfig(TIMx, &TIM_BDTRInitStruct) to configure the Timer
   2202                    
   2203                (#) Enable the Main Output using TIM_CtrlPWMOutputs(TIM1, ENABLE) 
   2204                    
   2205                (#) Once the break even occurs, the Timer's output signals are put in reset
   2206                    state or in a known state (according to the configuration made in
   2207                    TIM_BDTRConfig() function).
   2208          
   2209          @endverbatim
   2210            * @{
   2211            */
   2212          
   2213          /**
   2214            * @brief  Configures the Break feature, dead time, Lock level, OSSI/OSSR State
   2215            *         and the AOE(automatic output enable).
   2216            * @param  TIMx: where x can be  1 or 8 to select the TIM 
   2217            * @param  TIM_BDTRInitStruct: pointer to a TIM_BDTRInitTypeDef structure that
   2218            *         contains the BDTR Register configuration  information for the TIM peripheral.
   2219            * @retval None
   2220            */
   2221          void TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct)
   2222          {
   2223            /* Check the parameters */
   2224            assert_param(IS_TIM_LIST4_PERIPH(TIMx));
   2225            assert_param(IS_TIM_OSSR_STATE(TIM_BDTRInitStruct->TIM_OSSRState));
   2226            assert_param(IS_TIM_OSSI_STATE(TIM_BDTRInitStruct->TIM_OSSIState));
   2227            assert_param(IS_TIM_LOCK_LEVEL(TIM_BDTRInitStruct->TIM_LOCKLevel));
   2228            assert_param(IS_TIM_BREAK_STATE(TIM_BDTRInitStruct->TIM_Break));
   2229            assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
   2230            assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));
   2231          
   2232            /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
   2233               the OSSI State, the dead time value and the Automatic Output Enable Bit */
   2234            TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
   2235                       TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
   2236                       TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
   2237                       TIM_BDTRInitStruct->TIM_AutomaticOutput;
   2238          }
   2239          
   2240          /**
   2241            * @brief  Fills each TIM_BDTRInitStruct member with its default value.
   2242            * @param  TIM_BDTRInitStruct: pointer to a TIM_BDTRInitTypeDef structure which
   2243            *         will be initialized.
   2244            * @retval None
   2245            */
   2246          void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)
   2247          {
   2248            /* Set the default configuration */
   2249            TIM_BDTRInitStruct->TIM_OSSRState = TIM_OSSRState_Disable;
   2250            TIM_BDTRInitStruct->TIM_OSSIState = TIM_OSSIState_Disable;
   2251            TIM_BDTRInitStruct->TIM_LOCKLevel = TIM_LOCKLevel_OFF;
   2252            TIM_BDTRInitStruct->TIM_DeadTime = 0x00;
   2253            TIM_BDTRInitStruct->TIM_Break = TIM_Break_Disable;
   2254            TIM_BDTRInitStruct->TIM_BreakPolarity = TIM_BreakPolarity_Low;
   2255            TIM_BDTRInitStruct->TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
   2256          }
   2257          
   2258          /**
   2259            * @brief  Enables or disables the TIM peripheral Main Outputs.
   2260            * @param  TIMx: where x can be 1 or 8 to select the TIMx peripheral.
   2261            * @param  NewState: new state of the TIM peripheral Main Outputs.
   2262            *          This parameter can be: ENABLE or DISABLE.
   2263            * @retval None
   2264            */
   2265          void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState)
   2266          {
   2267            /* Check the parameters */
   2268            assert_param(IS_TIM_LIST4_PERIPH(TIMx));
   2269            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2270          
   2271            if (NewState != DISABLE)
   2272            {
   2273              /* Enable the TIM Main Output */
   2274              TIMx->BDTR |= TIM_BDTR_MOE;
   2275            }
   2276            else
   2277            {
   2278              /* Disable the TIM Main Output */
   2279              TIMx->BDTR &= (uint16_t)~TIM_BDTR_MOE;
   2280            }  
   2281          }
   2282          
   2283          /**
   2284            * @brief  Selects the TIM peripheral Commutation event.
   2285            * @param  TIMx: where x can be  1 or 8 to select the TIMx peripheral
   2286            * @param  NewState: new state of the Commutation event.
   2287            *          This parameter can be: ENABLE or DISABLE.
   2288            * @retval None
   2289            */
   2290          void TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState)
   2291          {
   2292            /* Check the parameters */
   2293            assert_param(IS_TIM_LIST4_PERIPH(TIMx));
   2294            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2295          
   2296            if (NewState != DISABLE)
   2297            {
   2298              /* Set the COM Bit */
   2299              TIMx->CR2 |= TIM_CR2_CCUS;
   2300            }
   2301            else
   2302            {
   2303              /* Reset the COM Bit */
   2304              TIMx->CR2 &= (uint16_t)~TIM_CR2_CCUS;
   2305            }
   2306          }
   2307          
   2308          /**
   2309            * @brief  Sets or Resets the TIM peripheral Capture Compare Preload Control bit.
   2310            * @param  TIMx: where x can be  1 or 8 to select the TIMx peripheral
   2311            * @param  NewState: new state of the Capture Compare Preload Control bit
   2312            *          This parameter can be: ENABLE or DISABLE.
   2313            * @retval None
   2314            */
   2315          void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState)
   2316          { 
   2317            /* Check the parameters */
   2318            assert_param(IS_TIM_LIST4_PERIPH(TIMx));
   2319            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2320            if (NewState != DISABLE)
   2321            {
   2322              /* Set the CCPC Bit */
   2323              TIMx->CR2 |= TIM_CR2_CCPC;
   2324            }
   2325            else
   2326            {
   2327              /* Reset the CCPC Bit */
   2328              TIMx->CR2 &= (uint16_t)~TIM_CR2_CCPC;
   2329            }
   2330          }
   2331          /**
   2332            * @}
   2333            */
   2334          
   2335          /** @defgroup TIM_Group5 Interrupts DMA and flags management functions
   2336           *  @brief    Interrupts, DMA and flags management functions 
   2337           *
   2338          @verbatim   
   2339           ===============================================================================
   2340                    ##### Interrupts, DMA and flags management functions #####
   2341           ===============================================================================  
   2342          
   2343          @endverbatim
   2344            * @{
   2345            */
   2346          
   2347          /**
   2348            * @brief  Enables or disables the specified TIM interrupts.
   2349            * @param  TIMx: where x can be 1 to 14 to select the TIMx peripheral.
   2350            * @param  TIM_IT: specifies the TIM interrupts sources to be enabled or disabled.
   2351            *          This parameter can be any combination of the following values:
   2352            *            @arg TIM_IT_Update: TIM update Interrupt source
   2353            *            @arg TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
   2354            *            @arg TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
   2355            *            @arg TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
   2356            *            @arg TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
   2357            *            @arg TIM_IT_COM: TIM Commutation Interrupt source
   2358            *            @arg TIM_IT_Trigger: TIM Trigger Interrupt source
   2359            *            @arg TIM_IT_Break: TIM Break Interrupt source
   2360            *  
   2361            * @note   For TIM6 and TIM7 only the parameter TIM_IT_Update can be used
   2362            * @note   For TIM9 and TIM12 only one of the following parameters can be used: TIM_IT_Update,
   2363            *          TIM_IT_CC1, TIM_IT_CC2 or TIM_IT_Trigger. 
   2364            * @note   For TIM10, TIM11, TIM13 and TIM14 only one of the following parameters can
   2365            *          be used: TIM_IT_Update or TIM_IT_CC1   
   2366            * @note   TIM_IT_COM and TIM_IT_Break can be used only with TIM1 and TIM8 
   2367            *        
   2368            * @param  NewState: new state of the TIM interrupts.
   2369            *          This parameter can be: ENABLE or DISABLE.
   2370            * @retval None
   2371            */
   2372          void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState)
   2373          {  
   2374            /* Check the parameters */
   2375            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2376            assert_param(IS_TIM_IT(TIM_IT));
   2377            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2378            
   2379            if (NewState != DISABLE)
   2380            {
   2381              /* Enable the Interrupt sources */
   2382              TIMx->DIER |= TIM_IT;
   2383            }
   2384            else
   2385            {
   2386              /* Disable the Interrupt sources */
   2387              TIMx->DIER &= (uint16_t)~TIM_IT;
   2388            }
   2389          }
   2390          
   2391          /**
   2392            * @brief  Configures the TIMx event to be generate by software.
   2393            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
   2394            * @param  TIM_EventSource: specifies the event source.
   2395            *          This parameter can be one or more of the following values:	   
   2396            *            @arg TIM_EventSource_Update: Timer update Event source
   2397            *            @arg TIM_EventSource_CC1: Timer Capture Compare 1 Event source
   2398            *            @arg TIM_EventSource_CC2: Timer Capture Compare 2 Event source
   2399            *            @arg TIM_EventSource_CC3: Timer Capture Compare 3 Event source
   2400            *            @arg TIM_EventSource_CC4: Timer Capture Compare 4 Event source
   2401            *            @arg TIM_EventSource_COM: Timer COM event source  
   2402            *            @arg TIM_EventSource_Trigger: Timer Trigger Event source
   2403            *            @arg TIM_EventSource_Break: Timer Break event source
   2404            * 
   2405            * @note   TIM6 and TIM7 can only generate an update event. 
   2406            * @note   TIM_EventSource_COM and TIM_EventSource_Break are used only with TIM1 and TIM8.
   2407            *        
   2408            * @retval None
   2409            */
   2410          void TIM_GenerateEvent(TIM_TypeDef* TIMx, uint16_t TIM_EventSource)
   2411          { 
   2412            /* Check the parameters */
   2413            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2414            assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource));
   2415           
   2416            /* Set the event sources */
   2417            TIMx->EGR = TIM_EventSource;
   2418          }
   2419          
   2420          /**
   2421            * @brief  Checks whether the specified TIM flag is set or not.
   2422            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
   2423            * @param  TIM_FLAG: specifies the flag to check.
   2424            *          This parameter can be one of the following values:
   2425            *            @arg TIM_FLAG_Update: TIM update Flag
   2426            *            @arg TIM_FLAG_CC1: TIM Capture Compare 1 Flag
   2427            *            @arg TIM_FLAG_CC2: TIM Capture Compare 2 Flag
   2428            *            @arg TIM_FLAG_CC3: TIM Capture Compare 3 Flag
   2429            *            @arg TIM_FLAG_CC4: TIM Capture Compare 4 Flag
   2430            *            @arg TIM_FLAG_COM: TIM Commutation Flag
   2431            *            @arg TIM_FLAG_Trigger: TIM Trigger Flag
   2432            *            @arg TIM_FLAG_Break: TIM Break Flag
   2433            *            @arg TIM_FLAG_CC1OF: TIM Capture Compare 1 over capture Flag
   2434            *            @arg TIM_FLAG_CC2OF: TIM Capture Compare 2 over capture Flag
   2435            *            @arg TIM_FLAG_CC3OF: TIM Capture Compare 3 over capture Flag
   2436            *            @arg TIM_FLAG_CC4OF: TIM Capture Compare 4 over capture Flag
   2437            *
   2438            * @note   TIM6 and TIM7 can have only one update flag. 
   2439            * @note   TIM_FLAG_COM and TIM_FLAG_Break are used only with TIM1 and TIM8.    
   2440            *
   2441            * @retval The new state of TIM_FLAG (SET or RESET).
   2442            */
   2443          FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
   2444          { 
   2445            ITStatus bitstatus = RESET;  
   2446            /* Check the parameters */
   2447            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2448            assert_param(IS_TIM_GET_FLAG(TIM_FLAG));
   2449          
   2450            
   2451            if ((TIMx->SR & TIM_FLAG) != (uint16_t)RESET)
   2452            {
   2453              bitstatus = SET;
   2454            }
   2455            else
   2456            {
   2457              bitstatus = RESET;
   2458            }
   2459            return bitstatus;
   2460          }
   2461          
   2462          /**
   2463            * @brief  Clears the TIMx's pending flags.
   2464            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
   2465            * @param  TIM_FLAG: specifies the flag bit to clear.
   2466            *          This parameter can be any combination of the following values:
   2467            *            @arg TIM_FLAG_Update: TIM update Flag
   2468            *            @arg TIM_FLAG_CC1: TIM Capture Compare 1 Flag
   2469            *            @arg TIM_FLAG_CC2: TIM Capture Compare 2 Flag
   2470            *            @arg TIM_FLAG_CC3: TIM Capture Compare 3 Flag
   2471            *            @arg TIM_FLAG_CC4: TIM Capture Compare 4 Flag
   2472            *            @arg TIM_FLAG_COM: TIM Commutation Flag
   2473            *            @arg TIM_FLAG_Trigger: TIM Trigger Flag
   2474            *            @arg TIM_FLAG_Break: TIM Break Flag
   2475            *            @arg TIM_FLAG_CC1OF: TIM Capture Compare 1 over capture Flag
   2476            *            @arg TIM_FLAG_CC2OF: TIM Capture Compare 2 over capture Flag
   2477            *            @arg TIM_FLAG_CC3OF: TIM Capture Compare 3 over capture Flag
   2478            *            @arg TIM_FLAG_CC4OF: TIM Capture Compare 4 over capture Flag
   2479            *
   2480            * @note   TIM6 and TIM7 can have only one update flag. 
   2481            * @note   TIM_FLAG_COM and TIM_FLAG_Break are used only with TIM1 and TIM8.
   2482            *    
   2483            * @retval None
   2484            */
   2485          void TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
   2486          {  
   2487            /* Check the parameters */
   2488            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2489             
   2490            /* Clear the flags */
   2491            TIMx->SR = (uint16_t)~TIM_FLAG;
   2492          }
   2493          
   2494          /**
   2495            * @brief  Checks whether the TIM interrupt has occurred or not.
   2496            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
   2497            * @param  TIM_IT: specifies the TIM interrupt source to check.
   2498            *          This parameter can be one of the following values:
   2499            *            @arg TIM_IT_Update: TIM update Interrupt source
   2500            *            @arg TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
   2501            *            @arg TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
   2502            *            @arg TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
   2503            *            @arg TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
   2504            *            @arg TIM_IT_COM: TIM Commutation Interrupt source
   2505            *            @arg TIM_IT_Trigger: TIM Trigger Interrupt source
   2506            *            @arg TIM_IT_Break: TIM Break Interrupt source
   2507            *
   2508            * @note   TIM6 and TIM7 can generate only an update interrupt.
   2509            * @note   TIM_IT_COM and TIM_IT_Break are used only with TIM1 and TIM8.
   2510            *     
   2511            * @retval The new state of the TIM_IT(SET or RESET).
   2512            */
   2513          ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT)
   2514          {
   2515            ITStatus bitstatus = RESET;  
   2516            uint16_t itstatus = 0x0, itenable = 0x0;
   2517            /* Check the parameters */
   2518            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2519            assert_param(IS_TIM_GET_IT(TIM_IT));
   2520             
   2521            itstatus = TIMx->SR & TIM_IT;
   2522            
   2523            itenable = TIMx->DIER & TIM_IT;
   2524            if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
   2525            {
   2526              bitstatus = SET;
   2527            }
   2528            else
   2529            {
   2530              bitstatus = RESET;
   2531            }
   2532            return bitstatus;
   2533          }
   2534          
   2535          /**
   2536            * @brief  Clears the TIMx's interrupt pending bits.
   2537            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
   2538            * @param  TIM_IT: specifies the pending bit to clear.
   2539            *          This parameter can be any combination of the following values:
   2540            *            @arg TIM_IT_Update: TIM1 update Interrupt source
   2541            *            @arg TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
   2542            *            @arg TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
   2543            *            @arg TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
   2544            *            @arg TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
   2545            *            @arg TIM_IT_COM: TIM Commutation Interrupt source
   2546            *            @arg TIM_IT_Trigger: TIM Trigger Interrupt source
   2547            *            @arg TIM_IT_Break: TIM Break Interrupt source
   2548            *
   2549            * @note   TIM6 and TIM7 can generate only an update interrupt.
   2550            * @note   TIM_IT_COM and TIM_IT_Break are used only with TIM1 and TIM8.
   2551            *      
   2552            * @retval None
   2553            */
   2554          void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT)
   2555          {
   2556            /* Check the parameters */
   2557            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2558          
   2559            /* Clear the IT pending Bit */
   2560            TIMx->SR = (uint16_t)~TIM_IT;
   2561          }
   2562          
   2563          /**
   2564            * @brief  Configures the TIMx's DMA interface.
   2565            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2566            * @param  TIM_DMABase: DMA Base address.
   2567            *          This parameter can be one of the following values:
   2568            *            @arg TIM_DMABase_CR1  
   2569            *            @arg TIM_DMABase_CR2
   2570            *            @arg TIM_DMABase_SMCR
   2571            *            @arg TIM_DMABase_DIER
   2572            *            @arg TIM1_DMABase_SR
   2573            *            @arg TIM_DMABase_EGR
   2574            *            @arg TIM_DMABase_CCMR1
   2575            *            @arg TIM_DMABase_CCMR2
   2576            *            @arg TIM_DMABase_CCER
   2577            *            @arg TIM_DMABase_CNT   
   2578            *            @arg TIM_DMABase_PSC   
   2579            *            @arg TIM_DMABase_ARR
   2580            *            @arg TIM_DMABase_RCR
   2581            *            @arg TIM_DMABase_CCR1
   2582            *            @arg TIM_DMABase_CCR2
   2583            *            @arg TIM_DMABase_CCR3  
   2584            *            @arg TIM_DMABase_CCR4
   2585            *            @arg TIM_DMABase_BDTR
   2586            *            @arg TIM_DMABase_DCR
   2587            * @param  TIM_DMABurstLength: DMA Burst length. This parameter can be one value
   2588            *         between: TIM_DMABurstLength_1Transfer and TIM_DMABurstLength_18Transfers.
   2589            * @retval None
   2590            */
   2591          void TIM_DMAConfig(TIM_TypeDef* TIMx, uint16_t TIM_DMABase, uint16_t TIM_DMABurstLength)
   2592          {
   2593            /* Check the parameters */
   2594            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   2595            assert_param(IS_TIM_DMA_BASE(TIM_DMABase)); 
   2596            assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));
   2597          
   2598            /* Set the DMA Base and the DMA Burst Length */
   2599            TIMx->DCR = TIM_DMABase | TIM_DMABurstLength;
   2600          }
   2601          
   2602          /**
   2603            * @brief  Enables or disables the TIMx's DMA Requests.
   2604            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the TIM peripheral.
   2605            * @param  TIM_DMASource: specifies the DMA Request sources.
   2606            *          This parameter can be any combination of the following values:
   2607            *            @arg TIM_DMA_Update: TIM update Interrupt source
   2608            *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
   2609            *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
   2610            *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
   2611            *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
   2612            *            @arg TIM_DMA_COM: TIM Commutation DMA source
   2613            *            @arg TIM_DMA_Trigger: TIM Trigger DMA source
   2614            * @param  NewState: new state of the DMA Request sources.
   2615            *          This parameter can be: ENABLE or DISABLE.
   2616            * @retval None
   2617            */
   2618          void TIM_DMACmd(TIM_TypeDef* TIMx, uint16_t TIM_DMASource, FunctionalState NewState)
   2619          { 
   2620            /* Check the parameters */
   2621            assert_param(IS_TIM_LIST5_PERIPH(TIMx)); 
   2622            assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
   2623            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2624            
   2625            if (NewState != DISABLE)
   2626            {
   2627              /* Enable the DMA sources */
   2628              TIMx->DIER |= TIM_DMASource; 
   2629            }
   2630            else
   2631            {
   2632              /* Disable the DMA sources */
   2633              TIMx->DIER &= (uint16_t)~TIM_DMASource;
   2634            }
   2635          }
   2636          
   2637          /**
   2638            * @brief  Selects the TIMx peripheral Capture Compare DMA source.
   2639            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2640            * @param  NewState: new state of the Capture Compare DMA source
   2641            *          This parameter can be: ENABLE or DISABLE.
   2642            * @retval None
   2643            */
   2644          void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState)
   2645          {
   2646            /* Check the parameters */
   2647            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   2648            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2649          
   2650            if (NewState != DISABLE)
   2651            {
   2652              /* Set the CCDS Bit */
   2653              TIMx->CR2 |= TIM_CR2_CCDS;
   2654            }
   2655            else
   2656            {
   2657              /* Reset the CCDS Bit */
   2658              TIMx->CR2 &= (uint16_t)~TIM_CR2_CCDS;
   2659            }
   2660          }
   2661          /**
   2662            * @}
   2663            */
   2664          
   2665          /** @defgroup TIM_Group6 Clocks management functions
   2666           *  @brief    Clocks management functions
   2667           *
   2668          @verbatim   
   2669           ===============================================================================
   2670                            ##### Clocks management functions #####
   2671           ===============================================================================  
   2672          
   2673          @endverbatim
   2674            * @{
   2675            */
   2676          
   2677          /**
   2678            * @brief  Configures the TIMx internal Clock
   2679            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   2680            *         peripheral.
   2681            * @retval None
   2682            */
   2683          void TIM_InternalClockConfig(TIM_TypeDef* TIMx)
   2684          {
   2685            /* Check the parameters */
   2686            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   2687          
   2688            /* Disable slave mode to clock the prescaler directly with the internal clock */
   2689            TIMx->SMCR &=  (uint16_t)~TIM_SMCR_SMS;
   2690          }
   2691          
   2692          /**
   2693            * @brief  Configures the TIMx Internal Trigger as External Clock
   2694            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   2695            *         peripheral.
   2696            * @param  TIM_InputTriggerSource: Trigger source.
   2697            *          This parameter can be one of the following values:
   2698            *            @arg TIM_TS_ITR0: Internal Trigger 0
   2699            *            @arg TIM_TS_ITR1: Internal Trigger 1
   2700            *            @arg TIM_TS_ITR2: Internal Trigger 2
   2701            *            @arg TIM_TS_ITR3: Internal Trigger 3
   2702            * @retval None
   2703            */
   2704          void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
   2705          {
   2706            /* Check the parameters */
   2707            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   2708            assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));
   2709          
   2710            /* Select the Internal Trigger */
   2711            TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
   2712          
   2713            /* Select the External clock mode1 */
   2714            TIMx->SMCR |= TIM_SlaveMode_External1;
   2715          }
   2716          
   2717          /**
   2718            * @brief  Configures the TIMx Trigger as External Clock
   2719            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13 or 14  
   2720            *         to select the TIM peripheral.
   2721            * @param  TIM_TIxExternalCLKSource: Trigger source.
   2722            *          This parameter can be one of the following values:
   2723            *            @arg TIM_TIxExternalCLK1Source_TI1ED: TI1 Edge Detector
   2724            *            @arg TIM_TIxExternalCLK1Source_TI1: Filtered Timer Input 1
   2725            *            @arg TIM_TIxExternalCLK1Source_TI2: Filtered Timer Input 2
   2726            * @param  TIM_ICPolarity: specifies the TIx Polarity.
   2727            *          This parameter can be one of the following values:
   2728            *            @arg TIM_ICPolarity_Rising
   2729            *            @arg TIM_ICPolarity_Falling
   2730            * @param  ICFilter: specifies the filter value.
   2731            *          This parameter must be a value between 0x0 and 0xF.
   2732            * @retval None
   2733            */
   2734          void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
   2735                                          uint16_t TIM_ICPolarity, uint16_t ICFilter)
   2736          {
   2737            /* Check the parameters */
   2738            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   2739            assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
   2740            assert_param(IS_TIM_IC_FILTER(ICFilter));
   2741          
   2742            /* Configure the Timer Input Clock Source */
   2743            if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
   2744            {
   2745              TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
   2746            }
   2747            else
   2748            {
   2749              TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
   2750            }
   2751            /* Select the Trigger source */
   2752            TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
   2753            /* Select the External clock mode1 */
   2754            TIMx->SMCR |= TIM_SlaveMode_External1;
   2755          }
   2756          
   2757          /**
   2758            * @brief  Configures the External clock Mode1
   2759            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2760            * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.
   2761            *          This parameter can be one of the following values:
   2762            *            @arg TIM_ExtTRGPSC_OFF: ETRP Prescaler OFF.
   2763            *            @arg TIM_ExtTRGPSC_DIV2: ETRP frequency divided by 2.
   2764            *            @arg TIM_ExtTRGPSC_DIV4: ETRP frequency divided by 4.
   2765            *            @arg TIM_ExtTRGPSC_DIV8: ETRP frequency divided by 8.
   2766            * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.
   2767            *          This parameter can be one of the following values:
   2768            *            @arg TIM_ExtTRGPolarity_Inverted: active low or falling edge active.
   2769            *            @arg TIM_ExtTRGPolarity_NonInverted: active high or rising edge active.
   2770            * @param  ExtTRGFilter: External Trigger Filter.
   2771            *          This parameter must be a value between 0x00 and 0x0F
   2772            * @retval None
   2773            */
   2774          void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler,
   2775                                      uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
   2776          {
   2777            uint16_t tmpsmcr = 0;
   2778          
   2779            /* Check the parameters */
   2780            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   2781            assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
   2782            assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
   2783            assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
   2784            /* Configure the ETR Clock source */
   2785            TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
   2786            
   2787            /* Get the TIMx SMCR register value */
   2788            tmpsmcr = TIMx->SMCR;
   2789          
   2790            /* Reset the SMS Bits */
   2791            tmpsmcr &= (uint16_t)~TIM_SMCR_SMS;
   2792          
   2793            /* Select the External clock mode1 */
   2794            tmpsmcr |= TIM_SlaveMode_External1;
   2795          
   2796            /* Select the Trigger selection : ETRF */
   2797            tmpsmcr &= (uint16_t)~TIM_SMCR_TS;
   2798            tmpsmcr |= TIM_TS_ETRF;
   2799          
   2800            /* Write to TIMx SMCR */
   2801            TIMx->SMCR = tmpsmcr;
   2802          }
   2803          
   2804          /**
   2805            * @brief  Configures the External clock Mode2
   2806            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2807            * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.
   2808            *          This parameter can be one of the following values:
   2809            *            @arg TIM_ExtTRGPSC_OFF: ETRP Prescaler OFF.
   2810            *            @arg TIM_ExtTRGPSC_DIV2: ETRP frequency divided by 2.
   2811            *            @arg TIM_ExtTRGPSC_DIV4: ETRP frequency divided by 4.
   2812            *            @arg TIM_ExtTRGPSC_DIV8: ETRP frequency divided by 8.
   2813            * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.
   2814            *          This parameter can be one of the following values:
   2815            *            @arg TIM_ExtTRGPolarity_Inverted: active low or falling edge active.
   2816            *            @arg TIM_ExtTRGPolarity_NonInverted: active high or rising edge active.
   2817            * @param  ExtTRGFilter: External Trigger Filter.
   2818            *          This parameter must be a value between 0x00 and 0x0F
   2819            * @retval None
   2820            */
   2821          void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, 
   2822                                       uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
   2823          {
   2824            /* Check the parameters */
   2825            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   2826            assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
   2827            assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
   2828            assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
   2829          
   2830            /* Configure the ETR Clock source */
   2831            TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
   2832          
   2833            /* Enable the External clock mode2 */
   2834            TIMx->SMCR |= TIM_SMCR_ECE;
   2835          }
   2836          /**
   2837            * @}
   2838            */
   2839          
   2840          /** @defgroup TIM_Group7 Synchronization management functions
   2841           *  @brief    Synchronization management functions 
   2842           *
   2843          @verbatim   
   2844           ===============================================================================
   2845                          ##### Synchronization management functions #####
   2846           ===============================================================================  
   2847                                   
   2848                    ##### TIM Driver: how to use it in synchronization Mode #####
   2849           ===============================================================================
   2850              [..] 
   2851              
   2852              *** Case of two/several Timers ***
   2853              ==================================
   2854              [..]
   2855                (#) Configure the Master Timers using the following functions:
   2856                  (++) void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource); 
   2857                  (++) void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode);  
   2858                (#) Configure the Slave Timers using the following functions: 
   2859                  (++) void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource);  
   2860                  (++) void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode); 
   2861                    
   2862              *** Case of Timers and external trigger(ETR pin) ***
   2863              ====================================================
   2864              [..]           
   2865                (#) Configure the External trigger using this function:
   2866                  (++) void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
   2867                                         uint16_t ExtTRGFilter);
   2868                (#) Configure the Slave Timers using the following functions: 
   2869                  (++) void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource);  
   2870                  (++) void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode); 
   2871          
   2872          @endverbatim
   2873            * @{
   2874            */
   2875          
   2876          /**
   2877            * @brief  Selects the Input Trigger source
   2878            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13 or 14  
   2879            *         to select the TIM peripheral.
   2880            * @param  TIM_InputTriggerSource: The Input Trigger source.
   2881            *          This parameter can be one of the following values:
   2882            *            @arg TIM_TS_ITR0: Internal Trigger 0
   2883            *            @arg TIM_TS_ITR1: Internal Trigger 1
   2884            *            @arg TIM_TS_ITR2: Internal Trigger 2
   2885            *            @arg TIM_TS_ITR3: Internal Trigger 3
   2886            *            @arg TIM_TS_TI1F_ED: TI1 Edge Detector
   2887            *            @arg TIM_TS_TI1FP1: Filtered Timer Input 1
   2888            *            @arg TIM_TS_TI2FP2: Filtered Timer Input 2
   2889            *            @arg TIM_TS_ETRF: External Trigger input
   2890            * @retval None
   2891            */
   2892          void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
   2893          {
   2894            uint16_t tmpsmcr = 0;
   2895          
   2896            /* Check the parameters */
   2897            assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
   2898            assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));
   2899          
   2900            /* Get the TIMx SMCR register value */
   2901            tmpsmcr = TIMx->SMCR;
   2902          
   2903            /* Reset the TS Bits */
   2904            tmpsmcr &= (uint16_t)~TIM_SMCR_TS;
   2905          
   2906            /* Set the Input Trigger source */
   2907            tmpsmcr |= TIM_InputTriggerSource;
   2908          
   2909            /* Write to TIMx SMCR */
   2910            TIMx->SMCR = tmpsmcr;
   2911          }
   2912          
   2913          /**
   2914            * @brief  Selects the TIMx Trigger Output Mode.
   2915            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the TIM peripheral.
   2916            *     
   2917            * @param  TIM_TRGOSource: specifies the Trigger Output source.
   2918            *   This parameter can be one of the following values:
   2919            *
   2920            *  - For all TIMx
   2921            *            @arg TIM_TRGOSource_Reset:  The UG bit in the TIM_EGR register is used as the trigger output(TRGO)
   2922            *            @arg TIM_TRGOSource_Enable: The Counter Enable CEN is used as the trigger output(TRGO)
   2923            *            @arg TIM_TRGOSource_Update: The update event is selected as the trigger output(TRGO)
   2924            *
   2925            *  - For all TIMx except TIM6 and TIM7
   2926            *            @arg TIM_TRGOSource_OC1: The trigger output sends a positive pulse when the CC1IF flag
   2927            *                                     is to be set, as soon as a capture or compare match occurs(TRGO)
   2928            *            @arg TIM_TRGOSource_OC1Ref: OC1REF signal is used as the trigger output(TRGO)
   2929            *            @arg TIM_TRGOSource_OC2Ref: OC2REF signal is used as the trigger output(TRGO)
   2930            *            @arg TIM_TRGOSource_OC3Ref: OC3REF signal is used as the trigger output(TRGO)
   2931            *            @arg TIM_TRGOSource_OC4Ref: OC4REF signal is used as the trigger output(TRGO)
   2932            *
   2933            * @retval None
   2934            */
   2935          void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource)
   2936          {
   2937            /* Check the parameters */
   2938            assert_param(IS_TIM_LIST5_PERIPH(TIMx));
   2939            assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));
   2940          
   2941            /* Reset the MMS Bits */
   2942            TIMx->CR2 &= (uint16_t)~TIM_CR2_MMS;
   2943            /* Select the TRGO source */
   2944            TIMx->CR2 |=  TIM_TRGOSource;
   2945          }
   2946          
   2947          /**
   2948            * @brief  Selects the TIMx Slave Mode.
   2949            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM peripheral.
   2950            * @param  TIM_SlaveMode: specifies the Timer Slave Mode.
   2951            *          This parameter can be one of the following values:
   2952            *            @arg TIM_SlaveMode_Reset: Rising edge of the selected trigger signal(TRGI) reinitialize 
   2953            *                                      the counter and triggers an update of the registers
   2954            *            @arg TIM_SlaveMode_Gated:     The counter clock is enabled when the trigger signal (TRGI) is high
   2955            *            @arg TIM_SlaveMode_Trigger:   The counter starts at a rising edge of the trigger TRGI
   2956            *            @arg TIM_SlaveMode_External1: Rising edges of the selected trigger (TRGI) clock the counter
   2957            * @retval None
   2958            */
   2959          void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode)
   2960          {
   2961            /* Check the parameters */
   2962            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   2963            assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));
   2964          
   2965            /* Reset the SMS Bits */
   2966            TIMx->SMCR &= (uint16_t)~TIM_SMCR_SMS;
   2967          
   2968            /* Select the Slave Mode */
   2969            TIMx->SMCR |= TIM_SlaveMode;
   2970          }
   2971          
   2972          /**
   2973            * @brief  Sets or Resets the TIMx Master/Slave Mode.
   2974            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM peripheral.
   2975            * @param  TIM_MasterSlaveMode: specifies the Timer Master Slave Mode.
   2976            *          This parameter can be one of the following values:
   2977            *            @arg TIM_MasterSlaveMode_Enable: synchronization between the current timer
   2978            *                                             and its slaves (through TRGO)
   2979            *            @arg TIM_MasterSlaveMode_Disable: No action
   2980            * @retval None
   2981            */
   2982          void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode)
   2983          {
   2984            /* Check the parameters */
   2985            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   2986            assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));
   2987          
   2988            /* Reset the MSM Bit */
   2989            TIMx->SMCR &= (uint16_t)~TIM_SMCR_MSM;
   2990            
   2991            /* Set or Reset the MSM Bit */
   2992            TIMx->SMCR |= TIM_MasterSlaveMode;
   2993          }
   2994          
   2995          /**
   2996            * @brief  Configures the TIMx External Trigger (ETR).
   2997            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2998            * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.
   2999            *          This parameter can be one of the following values:
   3000            *            @arg TIM_ExtTRGPSC_OFF: ETRP Prescaler OFF.
   3001            *            @arg TIM_ExtTRGPSC_DIV2: ETRP frequency divided by 2.
   3002            *            @arg TIM_ExtTRGPSC_DIV4: ETRP frequency divided by 4.
   3003            *            @arg TIM_ExtTRGPSC_DIV8: ETRP frequency divided by 8.
   3004            * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.
   3005            *          This parameter can be one of the following values:
   3006            *            @arg TIM_ExtTRGPolarity_Inverted: active low or falling edge active.
   3007            *            @arg TIM_ExtTRGPolarity_NonInverted: active high or rising edge active.
   3008            * @param  ExtTRGFilter: External Trigger Filter.
   3009            *          This parameter must be a value between 0x00 and 0x0F
   3010            * @retval None
   3011            */
   3012          void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler,
   3013                             uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
   3014          {
   3015            uint16_t tmpsmcr = 0;
   3016          
   3017            /* Check the parameters */
   3018            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   3019            assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
   3020            assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
   3021            assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
   3022          
   3023            tmpsmcr = TIMx->SMCR;
   3024          
   3025            /* Reset the ETR Bits */
   3026            tmpsmcr &= SMCR_ETR_MASK;
   3027          
   3028            /* Set the Prescaler, the Filter value and the Polarity */
   3029            tmpsmcr |= (uint16_t)(TIM_ExtTRGPrescaler | (uint16_t)(TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << (uint16_t)8)));
   3030          
   3031            /* Write to TIMx SMCR */
   3032            TIMx->SMCR = tmpsmcr;
   3033          }
   3034          /**
   3035            * @}
   3036            */
   3037          
   3038          /** @defgroup TIM_Group8 Specific interface management functions
   3039           *  @brief    Specific interface management functions 
   3040           *
   3041          @verbatim   
   3042           ===============================================================================
   3043                      ##### Specific interface management functions #####
   3044           ===============================================================================  
   3045          
   3046          @endverbatim
   3047            * @{
   3048            */
   3049          
   3050          /**
   3051            * @brief  Configures the TIMx Encoder Interface.
   3052            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   3053            *         peripheral.
   3054            * @param  TIM_EncoderMode: specifies the TIMx Encoder Mode.
   3055            *          This parameter can be one of the following values:
   3056            *            @arg TIM_EncoderMode_TI1: Counter counts on TI1FP1 edge depending on TI2FP2 level.
   3057            *            @arg TIM_EncoderMode_TI2: Counter counts on TI2FP2 edge depending on TI1FP1 level.
   3058            *            @arg TIM_EncoderMode_TI12: Counter counts on both TI1FP1 and TI2FP2 edges depending
   3059            *                                       on the level of the other input.
   3060            * @param  TIM_IC1Polarity: specifies the IC1 Polarity
   3061            *          This parameter can be one of the following values:
   3062            *            @arg TIM_ICPolarity_Falling: IC Falling edge.
   3063            *            @arg TIM_ICPolarity_Rising: IC Rising edge.
   3064            * @param  TIM_IC2Polarity: specifies the IC2 Polarity
   3065            *          This parameter can be one of the following values:
   3066            *            @arg TIM_ICPolarity_Falling: IC Falling edge.
   3067            *            @arg TIM_ICPolarity_Rising: IC Rising edge.
   3068            * @retval None
   3069            */
   3070          void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
   3071                                          uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity)
   3072          {
   3073            uint16_t tmpsmcr = 0;
   3074            uint16_t tmpccmr1 = 0;
   3075            uint16_t tmpccer = 0;
   3076              
   3077            /* Check the parameters */
   3078            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   3079            assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
   3080            assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
   3081            assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));
   3082          
   3083            /* Get the TIMx SMCR register value */
   3084            tmpsmcr = TIMx->SMCR;
   3085          
   3086            /* Get the TIMx CCMR1 register value */
   3087            tmpccmr1 = TIMx->CCMR1;
   3088          
   3089            /* Get the TIMx CCER register value */
   3090            tmpccer = TIMx->CCER;
   3091          
   3092            /* Set the encoder Mode */
   3093            tmpsmcr &= (uint16_t)~TIM_SMCR_SMS;
   3094            tmpsmcr |= TIM_EncoderMode;
   3095          
   3096            /* Select the Capture Compare 1 and the Capture Compare 2 as input */
   3097            tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_CC2S);
   3098            tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;
   3099          
   3100            /* Set the TI1 and the TI2 Polarities */
   3101            tmpccer &= ((uint16_t)~TIM_CCER_CC1P) & ((uint16_t)~TIM_CCER_CC2P);
   3102            tmpccer |= (uint16_t)(TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << (uint16_t)4));
   3103          
   3104            /* Write to TIMx SMCR */
   3105            TIMx->SMCR = tmpsmcr;
   3106          
   3107            /* Write to TIMx CCMR1 */
   3108            TIMx->CCMR1 = tmpccmr1;
   3109          
   3110            /* Write to TIMx CCER */
   3111            TIMx->CCER = tmpccer;
   3112          }
   3113          
   3114          /**
   3115            * @brief  Enables or disables the TIMx's Hall sensor interface.
   3116            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   3117            *         peripheral.
   3118            * @param  NewState: new state of the TIMx Hall sensor interface.
   3119            *          This parameter can be: ENABLE or DISABLE.
   3120            * @retval None
   3121            */
   3122          void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState)
   3123          {
   3124            /* Check the parameters */
   3125            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   3126            assert_param(IS_FUNCTIONAL_STATE(NewState));
   3127          
   3128            if (NewState != DISABLE)
   3129            {
   3130              /* Set the TI1S Bit */
   3131              TIMx->CR2 |= TIM_CR2_TI1S;
   3132            }
   3133            else
   3134            {
   3135              /* Reset the TI1S Bit */
   3136              TIMx->CR2 &= (uint16_t)~TIM_CR2_TI1S;
   3137            }
   3138          }
   3139          /**
   3140            * @}
   3141            */
   3142          
   3143          /** @defgroup TIM_Group9 Specific remapping management function
   3144           *  @brief   Specific remapping management function
   3145           *
   3146          @verbatim   
   3147           ===============================================================================
   3148                        ##### Specific remapping management function #####
   3149           ===============================================================================  
   3150          
   3151          @endverbatim
   3152            * @{
   3153            */
   3154          
   3155          /**
   3156            * @brief  Configures the TIM2, TIM5 and TIM11 Remapping input capabilities.
   3157            * @param  TIMx: where x can be 2, 5 or 11 to select the TIM peripheral.
   3158            * @param  TIM_Remap: specifies the TIM input remapping source.
   3159            *          This parameter can be one of the following values:
   3160            *            @arg TIM2_TIM8_TRGO: TIM2 ITR1 input is connected to TIM8 Trigger output(default)
   3161            *            @arg TIM2_ETH_PTP:   TIM2 ITR1 input is connected to ETH PTP trigger output.
   3162            *            @arg TIM2_USBFS_SOF: TIM2 ITR1 input is connected to USB FS SOF. 
   3163            *            @arg TIM2_USBHS_SOF: TIM2 ITR1 input is connected to USB HS SOF. 
   3164            *            @arg TIM5_GPIO:      TIM5 CH4 input is connected to dedicated Timer pin(default)
   3165            *            @arg TIM5_LSI:       TIM5 CH4 input is connected to LSI clock.
   3166            *            @arg TIM5_LSE:       TIM5 CH4 input is connected to LSE clock.
   3167            *            @arg TIM5_RTC:       TIM5 CH4 input is connected to RTC Output event.
   3168            *            @arg TIM11_GPIO:     TIM11 CH4 input is connected to dedicated Timer pin(default) 
   3169            *            @arg TIM11_HSE:      TIM11 CH4 input is connected to HSE_RTC clock
   3170            *                                 (HSE divided by a programmable prescaler)  
   3171            * @retval None
   3172            */
   3173          void TIM_RemapConfig(TIM_TypeDef* TIMx, uint16_t TIM_Remap)
   3174          {
   3175           /* Check the parameters */
   3176            assert_param(IS_TIM_LIST6_PERIPH(TIMx));
   3177            assert_param(IS_TIM_REMAP(TIM_Remap));
   3178          
   3179            /* Set the Timer remapping configuration */
   3180            TIMx->OR =  TIM_Remap;
   3181          }
   3182          /**
   3183            * @}
   3184            */
   3185          
   3186          /**
   3187            * @brief  Configure the TI1 as Input.
   3188            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13 or 14 
   3189            *         to select the TIM peripheral.
   3190            * @param  TIM_ICPolarity : The Input Polarity.
   3191            *          This parameter can be one of the following values:
   3192            *            @arg TIM_ICPolarity_Rising
   3193            *            @arg TIM_ICPolarity_Falling
   3194            *            @arg TIM_ICPolarity_BothEdge  
   3195            * @param  TIM_ICSelection: specifies the input to be used.
   3196            *          This parameter can be one of the following values:
   3197            *            @arg TIM_ICSelection_DirectTI: TIM Input 1 is selected to be connected to IC1.
   3198            *            @arg TIM_ICSelection_IndirectTI: TIM Input 1 is selected to be connected to IC2.
   3199            *            @arg TIM_ICSelection_TRC: TIM Input 1 is selected to be connected to TRC.
   3200            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   3201            *          This parameter must be a value between 0x00 and 0x0F.
   3202            * @retval None
   3203            */
   3204          static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
   3205                                 uint16_t TIM_ICFilter)
   3206          {
   3207            uint16_t tmpccmr1 = 0, tmpccer = 0;
   3208          
   3209            /* Disable the Channel 1: Reset the CC1E Bit */
   3210            TIMx->CCER &= (uint16_t)~TIM_CCER_CC1E;
   3211            tmpccmr1 = TIMx->CCMR1;
   3212            tmpccer = TIMx->CCER;
   3213          
   3214            /* Select the Input and set the filter */
   3215            tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_IC1F);
   3216            tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
   3217          
   3218            /* Select the Polarity and set the CC1E Bit */
   3219            tmpccer &= (uint16_t)~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
   3220            tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
   3221          
   3222            /* Write to TIMx CCMR1 and CCER registers */
   3223            TIMx->CCMR1 = tmpccmr1;
   3224            TIMx->CCER = tmpccer;
   3225          }
   3226          
   3227          /**
   3228            * @brief  Configure the TI2 as Input.
   3229            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   3230            *         peripheral.
   3231            * @param  TIM_ICPolarity : The Input Polarity.
   3232            *          This parameter can be one of the following values:
   3233            *            @arg TIM_ICPolarity_Rising
   3234            *            @arg TIM_ICPolarity_Falling
   3235            *            @arg TIM_ICPolarity_BothEdge   
   3236            * @param  TIM_ICSelection: specifies the input to be used.
   3237            *          This parameter can be one of the following values:
   3238            *            @arg TIM_ICSelection_DirectTI: TIM Input 2 is selected to be connected to IC2.
   3239            *            @arg TIM_ICSelection_IndirectTI: TIM Input 2 is selected to be connected to IC1.
   3240            *            @arg TIM_ICSelection_TRC: TIM Input 2 is selected to be connected to TRC.
   3241            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   3242            *          This parameter must be a value between 0x00 and 0x0F.
   3243            * @retval None
   3244            */
   3245          static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
   3246                                 uint16_t TIM_ICFilter)
   3247          {
   3248            uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
   3249          
   3250            /* Disable the Channel 2: Reset the CC2E Bit */
   3251            TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
   3252            tmpccmr1 = TIMx->CCMR1;
   3253            tmpccer = TIMx->CCER;
   3254            tmp = (uint16_t)(TIM_ICPolarity << 4);
   3255          
   3256            /* Select the Input and set the filter */
   3257            tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
   3258            tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
   3259            tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8);
   3260          
   3261            /* Select the Polarity and set the CC2E Bit */
   3262            tmpccer &= (uint16_t)~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
   3263            tmpccer |=  (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);
   3264          
   3265            /* Write to TIMx CCMR1 and CCER registers */
   3266            TIMx->CCMR1 = tmpccmr1 ;
   3267            TIMx->CCER = tmpccer;
   3268          }
   3269          
   3270          /**
   3271            * @brief  Configure the TI3 as Input.
   3272            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   3273            * @param  TIM_ICPolarity : The Input Polarity.
   3274            *          This parameter can be one of the following values:
   3275            *            @arg TIM_ICPolarity_Rising
   3276            *            @arg TIM_ICPolarity_Falling
   3277            *            @arg TIM_ICPolarity_BothEdge         
   3278            * @param  TIM_ICSelection: specifies the input to be used.
   3279            *          This parameter can be one of the following values:
   3280            *            @arg TIM_ICSelection_DirectTI: TIM Input 3 is selected to be connected to IC3.
   3281            *            @arg TIM_ICSelection_IndirectTI: TIM Input 3 is selected to be connected to IC4.
   3282            *            @arg TIM_ICSelection_TRC: TIM Input 3 is selected to be connected to TRC.
   3283            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   3284            *          This parameter must be a value between 0x00 and 0x0F.
   3285            * @retval None
   3286            */
   3287          static void TI3_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
   3288                                 uint16_t TIM_ICFilter)
   3289          {
   3290            uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
   3291          
   3292            /* Disable the Channel 3: Reset the CC3E Bit */
   3293            TIMx->CCER &= (uint16_t)~TIM_CCER_CC3E;
   3294            tmpccmr2 = TIMx->CCMR2;
   3295            tmpccer = TIMx->CCER;
   3296            tmp = (uint16_t)(TIM_ICPolarity << 8);
   3297          
   3298            /* Select the Input and set the filter */
   3299            tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR2_IC3F);
   3300            tmpccmr2 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
   3301          
   3302            /* Select the Polarity and set the CC3E Bit */
   3303            tmpccer &= (uint16_t)~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
   3304            tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC3E);
   3305          
   3306            /* Write to TIMx CCMR2 and CCER registers */
   3307            TIMx->CCMR2 = tmpccmr2;
   3308            TIMx->CCER = tmpccer;
   3309          }
   3310          
   3311          /**
   3312            * @brief  Configure the TI4 as Input.
   3313            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   3314            * @param  TIM_ICPolarity : The Input Polarity.
   3315            *          This parameter can be one of the following values:
   3316            *            @arg TIM_ICPolarity_Rising
   3317            *            @arg TIM_ICPolarity_Falling
   3318            *            @arg TIM_ICPolarity_BothEdge     
   3319            * @param  TIM_ICSelection: specifies the input to be used.
   3320            *          This parameter can be one of the following values:
   3321            *            @arg TIM_ICSelection_DirectTI: TIM Input 4 is selected to be connected to IC4.
   3322            *            @arg TIM_ICSelection_IndirectTI: TIM Input 4 is selected to be connected to IC3.
   3323            *            @arg TIM_ICSelection_TRC: TIM Input 4 is selected to be connected to TRC.
   3324            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   3325            *          This parameter must be a value between 0x00 and 0x0F.
   3326            * @retval None
   3327            */
   3328          static void TI4_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
   3329                                 uint16_t TIM_ICFilter)
   3330          {
   3331            uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
   3332          
   3333            /* Disable the Channel 4: Reset the CC4E Bit */
   3334            TIMx->CCER &= (uint16_t)~TIM_CCER_CC4E;
   3335            tmpccmr2 = TIMx->CCMR2;
   3336            tmpccer = TIMx->CCER;
   3337            tmp = (uint16_t)(TIM_ICPolarity << 12);
   3338          
   3339            /* Select the Input and set the filter */
   3340            tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
   3341            tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
   3342            tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);
   3343          
   3344            /* Select the Polarity and set the CC4E Bit */
   3345            tmpccer &= (uint16_t)~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
   3346            tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC4E);
   3347          
   3348            /* Write to TIMx CCMR2 and CCER registers */
   3349            TIMx->CCMR2 = tmpccmr2;
   3350            TIMx->CCER = tmpccer ;
   3351          }
   3352          
   3353          /**
   3354            * @}
   3355            */
   3356          
   3357          /**
   3358            * @}
   3359            */
   3360          
   3361          /**
   3362            * @}
   3363            */
   3364          
   3365          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   TI1_Config
      16   TI2_Config
       0   TIM_ARRPreloadConfig
       0   TIM_BDTRConfig
       0   TIM_BDTRStructInit
       0   TIM_CCPreloadControl
       8   TIM_CCxCmd
       8   TIM_CCxNCmd
       0   TIM_ClearFlag
       0   TIM_ClearITPendingBit
       0   TIM_ClearOC1Ref
       0   TIM_ClearOC2Ref
       0   TIM_ClearOC3Ref
       0   TIM_ClearOC4Ref
       0   TIM_Cmd
       0   TIM_CounterModeConfig
       0   TIM_CtrlPWMOutputs
       0   TIM_DMACmd
       0   TIM_DMAConfig
       8   TIM_DeInit
         0   -> RCC_APB1PeriphResetCmd
         8   -> RCC_APB1PeriphResetCmd
         0   -> RCC_APB2PeriphResetCmd
         8   -> RCC_APB2PeriphResetCmd
       8   TIM_ETRClockMode1Config
         8   -> TIM_ETRConfig
       8   TIM_ETRClockMode2Config
         8   -> TIM_ETRConfig
       8   TIM_ETRConfig
      20   TIM_EncoderInterfaceConfig
       0   TIM_ForcedOC1Config
       0   TIM_ForcedOC2Config
       0   TIM_ForcedOC3Config
       0   TIM_ForcedOC4Config
       0   TIM_GenerateEvent
       0   TIM_GetCapture1
       0   TIM_GetCapture2
       0   TIM_GetCapture3
       0   TIM_GetCapture4
       0   TIM_GetCounter
       0   TIM_GetFlagStatus
       0   TIM_GetITStatus
       0   TIM_GetPrescaler
      24   TIM_ICInit
        24   -> TI1_Config
        24   -> TI2_Config
         0   -> TIM_SetIC1Prescaler
         0   -> TIM_SetIC2Prescaler
         0   -> TIM_SetIC3Prescaler
         0   -> TIM_SetIC4Prescaler
       0   TIM_ICStructInit
       0   TIM_ITConfig
       8   TIM_ITRxExternalClockConfig
         8   -> TIM_SelectInputTrigger
       0   TIM_InternalClockConfig
       0   TIM_OC1FastConfig
      12   TIM_OC1Init
       0   TIM_OC1NPolarityConfig
       0   TIM_OC1PolarityConfig
       0   TIM_OC1PreloadConfig
       0   TIM_OC2FastConfig
      16   TIM_OC2Init
       0   TIM_OC2NPolarityConfig
       0   TIM_OC2PolarityConfig
       0   TIM_OC2PreloadConfig
       0   TIM_OC3FastConfig
      16   TIM_OC3Init
       0   TIM_OC3NPolarityConfig
       0   TIM_OC3PolarityConfig
       0   TIM_OC3PreloadConfig
       0   TIM_OC4FastConfig
      16   TIM_OC4Init
       0   TIM_OC4PolarityConfig
       0   TIM_OC4PreloadConfig
       0   TIM_OCStructInit
      24   TIM_PWMIConfig
        24   -> TI1_Config
        24   -> TI2_Config
         0   -> TIM_SetIC1Prescaler
        24   -> TIM_SetIC1Prescaler
         0   -> TIM_SetIC2Prescaler
        24   -> TIM_SetIC2Prescaler
       0   TIM_PrescalerConfig
       0   TIM_RemapConfig
       0   TIM_SelectCCDMA
       0   TIM_SelectCOM
       0   TIM_SelectHallSensor
       0   TIM_SelectInputTrigger
       0   TIM_SelectMasterSlaveMode
      12   TIM_SelectOCxM
       0   TIM_SelectOnePulseMode
       0   TIM_SelectOutputTrigger
       0   TIM_SelectSlaveMode
       0   TIM_SetAutoreload
       0   TIM_SetClockDivision
       0   TIM_SetCompare1
       0   TIM_SetCompare2
       0   TIM_SetCompare3
       0   TIM_SetCompare4
       0   TIM_SetCounter
       0   TIM_SetIC1Prescaler
       0   TIM_SetIC2Prescaler
       0   TIM_SetIC3Prescaler
       0   TIM_SetIC4Prescaler
      16   TIM_TIxExternalClockConfig
        16   -> TI1_Config
        16   -> TI2_Config
        16   -> TIM_SelectInputTrigger
      12   TIM_TimeBaseInit
       0   TIM_TimeBaseStructInit
       0   TIM_UpdateDisableConfig
       0   TIM_UpdateRequestConfig


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_10
       4  ??DataTable5_11
       4  ??DataTable5_12
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
       4  ??DataTable5_8
       4  ??DataTable5_9
      12  ?Subroutine0
      12  ?Subroutine1
       6  ?Subroutine10
      18  ?Subroutine11
      16  ?Subroutine12
      16  ?Subroutine13
      10  ?Subroutine2
      10  ?Subroutine3
      10  ?Subroutine4
      10  ?Subroutine5
       8  ?Subroutine6
       8  ?Subroutine7
       8  ?Subroutine8
       6  ?Subroutine9
      46  TI1_Config
      50  TI2_Config
      20  TIM_ARRPreloadConfig
      28  TIM_BDTRConfig
      18  TIM_BDTRStructInit
      20  TIM_CCPreloadControl
       8  TIM_CCxCmd
       6  TIM_CCxNCmd
       2  TIM_ClearFlag
       2  TIM_ClearITPendingBit
       8  TIM_ClearOC1Ref
       8  TIM_ClearOC2Ref
       8  TIM_ClearOC3Ref
       8  TIM_ClearOC4Ref
      20  TIM_Cmd
      10  TIM_CounterModeConfig
      16  TIM_CtrlPWMOutputs
      16  TIM_DMACmd
       8  TIM_DMAConfig
     320  TIM_DeInit
      18  TIM_ETRClockMode1Config
      18  TIM_ETRClockMode2Config
      18  TIM_ETRConfig
      48  TIM_EncoderInterfaceConfig
       8  TIM_ForcedOC1Config
       8  TIM_ForcedOC2Config
       8  TIM_ForcedOC3Config
       8  TIM_ForcedOC4Config
       4  TIM_GenerateEvent
       4  TIM_GetCapture1
       4  TIM_GetCapture2
       4  TIM_GetCapture3
       4  TIM_GetCapture4
       4  TIM_GetCounter
      14  TIM_GetFlagStatus
      20  TIM_GetITStatus
       4  TIM_GetPrescaler
     136  TIM_ICInit
      18  TIM_ICStructInit
      16  TIM_ITConfig
      18  TIM_ITRxExternalClockConfig
      12  TIM_InternalClockConfig
       8  TIM_OC1FastConfig
     100  TIM_OC1Init
       6  TIM_OC1NPolarityConfig
       8  TIM_OC1PolarityConfig
       6  TIM_OC1PreloadConfig
       8  TIM_OC2FastConfig
     110  TIM_OC2Init
       6  TIM_OC2NPolarityConfig
       8  TIM_OC2PolarityConfig
       6  TIM_OC2PreloadConfig
       8  TIM_OC3FastConfig
     108  TIM_OC3Init
       6  TIM_OC3NPolarityConfig
       8  TIM_OC3PolarityConfig
       6  TIM_OC3PreloadConfig
       8  TIM_OC4FastConfig
      82  TIM_OC4Init
      16  TIM_OC4PolarityConfig
       6  TIM_OC4PreloadConfig
      20  TIM_OCStructInit
      72  TIM_PWMIConfig
       6  TIM_PrescalerConfig
       6  TIM_RemapConfig
      20  TIM_SelectCCDMA
      20  TIM_SelectCOM
      20  TIM_SelectHallSensor
      10  TIM_SelectInputTrigger
       6  TIM_SelectMasterSlaveMode
      78  TIM_SelectOCxM
       8  TIM_SelectOnePulseMode
      18  TIM_SelectOutputTrigger
       8  TIM_SelectSlaveMode
       4  TIM_SetAutoreload
       6  TIM_SetClockDivision
       4  TIM_SetCompare1
       4  TIM_SetCompare2
       4  TIM_SetCompare3
       4  TIM_SetCompare4
       4  TIM_SetCounter
      14  TIM_SetIC1Prescaler
      14  TIM_SetIC2Prescaler
      14  TIM_SetIC3Prescaler
      14  TIM_SetIC4Prescaler
      44  TIM_TIxExternalClockConfig
      98  TIM_TimeBaseInit
      18  TIM_TimeBaseStructInit
      20  TIM_UpdateDisableConfig
      20  TIM_UpdateRequestConfig

 
 2 312 bytes in section .text
 
 2 312 bytes of CODE memory

Errors: none
Warnings: none
